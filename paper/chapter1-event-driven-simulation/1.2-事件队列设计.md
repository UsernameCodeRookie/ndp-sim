# 1.2 事件队列设计

## 概述

事件队列是事件驱动模拟的核心数据结构。本节详细分析事件队列的设计选择，包括数据结构的选择、实现细节以及性能考量。

## 1.2.1 优先级队列的选择

### 关键操作需求

事件队列需支持以下操作，且都要求高效：

| 操作 | 说明 | 期望复杂度 | 备注 |
|------|------|----------|------|
| Insert | 插入事件 | O(log n) | 频繁操作 |
| ExtractMin | 取最小元素 | O(log n) | 关键路径 |
| Delete | 删除元素 | O(log n) | 取消事件 |
| DecreaseKey | 修改关键字 | O(log n) | 事件延迟 |
| Peek | 查看最小元素 | O(1) | 预检查 |

### 候选数据结构对比

```
┌──────────────────┬──────────┬──────────┬──────────┬──────────┐
│ 数据结构          │ Insert   │ ExtMin   │ Delete   │ 空间     │
├──────────────────┼──────────┼──────────┼──────────┼──────────┤
│ 线性表(排序)      │ O(n)     │ O(1)     │ O(n)     │ O(n)     │
│ 线性表(无序)      │ O(1)     │ O(n)     │ O(1)     │ O(n)     │
│ 二叉堆(最小堆)    │ O(log n) │ O(log n) │ O(n)*    │ O(n)     │
│ 二项堆(Binomial)  │ O(1)摊   │ O(log n) │ O(log n) │ O(n)     │
│ 斐波那契堆         │ O(1)摊   │ O(log n) │ O(1)摊   │ O(n)     │
│ 红黑树            │ O(log n) │ O(log n) │ O(log n) │ O(n)     │
└──────────────────┴──────────┴──────────┴──────────┴──────────┘

* 带索引的二叉堆可做到O(log n)
摊: 摊销复杂度
```

### 推荐方案：二叉堆 + 索引表

对于体系结构模拟，推荐使用**二叉堆结合索引表**的方案：

**优点**:
1. 实现简单，代码量少
2. 内存局部性好，缓存友好
3. 常数因子小
4. 所有操作都是O(log n)

**C++实现框架**:
```cpp
class EventQueue {
private:
    std::vector<std::shared_ptr<Event>> heap_;
    std::unordered_map<Event::EventID, size_t> event_index_;
    
public:
    // 插入: O(log n)
    void insert(std::shared_ptr<Event> event);
    
    // 提取最小: O(log n)
    std::shared_ptr<Event> extractMin();
    
    // 删除(取消事件): O(log n)
    void remove(Event::EventID id);
};
```

## 1.2.2 二叉堆的具体实现

### 二叉堆的结构

二叉堆是一个完全二叉树，满足堆性质：
$$\text{parent}(i) \leq \text{left}(i), \text{parent}(i) \leq \text{right}(i)$$

用数组表示：
```
数组索引: 0  1  2  3  4  5  6   7   8   9  10  11  12
树形图:       0
             /  \
            1    2
           / \  / \
          3  4 5  6
         /|
        7 8 ...
```

### 堆操作详解

#### 上滤(Sift Up)操作

将新元素插入到末尾，然后上滤：

```cpp
void siftUp(size_t pos) {
    while (pos > 0) {
        size_t parent = (pos - 1) / 2;
        if (heap_[pos] < heap_[parent]) {
            std::swap(heap_[pos], heap_[parent]);
            updateIndex(heap_[pos], pos);
            updateIndex(heap_[parent], parent);
            pos = parent;
        } else {
            break;
        }
    }
}
```

时间复杂度: O(log n)，因为堆的高度是log n

#### 下滤(Sift Down)操作

删除根元素后，用末尾元素替换，然后下滤：

```cpp
void siftDown(size_t pos) {
    size_t smallest;
    while (2 * pos + 1 < heap_.size()) {
        size_t left = 2 * pos + 1;
        size_t right = 2 * pos + 2;
        smallest = pos;
        
        if (heap_[left] < heap_[smallest]) {
            smallest = left;
        }
        if (right < heap_.size() && 
            heap_[right] < heap_[smallest]) {
            smallest = right;
        }
        
        if (smallest != pos) {
            std::swap(heap_[pos], heap_[smallest]);
            updateIndex(heap_[pos], pos);
            updateIndex(heap_[smallest], smallest);
            pos = smallest;
        } else {
            break;
        }
    }
}
```

时间复杂度: O(log n)

### 索引表的维护

为了支持O(log n)的删除操作，需要维护一个id→位置的索引表：

```cpp
class EventQueue {
private:
    std::vector<std::shared_ptr<Event>> heap_;
    std::unordered_map<Event::EventID, size_t> id_to_pos_;
    
private:
    void updateIndex(std::shared_ptr<Event> event, size_t pos) {
        id_to_pos_[event->getID()] = pos;
    }
    
    void removeIndex(Event::EventID id) {
        id_to_pos_.erase(id);
    }
    
public:
    void remove(Event::EventID id) {
        auto it = id_to_pos_.find(id);
        if (it == id_to_pos_.end()) return;  // 不存在
        
        size_t pos = it->second;
        if (pos == heap_.size() - 1) {
            // 删除最后一个元素
            heap_.pop_back();
            removeIndex(id);
        } else {
            // 用最后一个元素替换，然后调整
            heap_[pos] = heap_.back();
            heap_.pop_back();
            updateIndex(heap_[pos], pos);
            removeIndex(id);
            siftDown(pos);
        }
    }
};
```

## 1.2.3 事件比较与优先级

### 比较规则

事件的比较需要考虑两个维度：

$$\text{优先级} = (时间, 优先级数)$$

```cpp
bool operator<(const Event& a, const Event& b) const {
    // 先比较时间（主排序键）
    if (a.getTime() != b.getTime()) {
        return a.getTime() < b.getTime();  // 早的事件优先
    }
    // 时间相同时，比较优先级数（次排序键）
    return a.getPriority() > b.getPriority();  // 高优先级数先执行
}
```

### 优先级数的含义

优先级数用于在同一时刻区分不同事件的执行顺序：

```
event_1: time=100, priority=10
event_2: time=100, priority=5
event_3: time=100, priority=15

执行顺序: event_3 (pri=15) → event_1 (pri=10) → event_2 (pri=5)
```

**最佳实践**:
- 优先级通常为[0, 100]的整数
- 预定义常用优先级常量
- 清晰文档化优先级含义

## 1.2.4 事件队列的完整实现

### 类定义

```cpp
class EventQueue {
public:
    using EventPtr = std::shared_ptr<Event>;
    
    EventQueue() : total_inserts_(0), total_extracts_(0) {}
    
    // 基本操作
    void insert(EventPtr event);
    EventPtr extractMin();
    bool empty() const;
    size_t size() const;
    
    // 队列管理
    void remove(Event::EventID id);
    EventPtr peek() const;
    void clear();
    
    // 统计信息
    uint64_t getTotalInserts() const { return total_inserts_; }
    uint64_t getTotalExtracts() const { return total_extracts_; }
    
private:
    std::vector<EventPtr> heap_;
    std::unordered_map<Event::EventID, size_t> id_to_pos_;
    uint64_t total_inserts_;
    uint64_t total_extracts_;
    
    // 堆操作
    void siftUp(size_t pos);
    void siftDown(size_t pos);
    void updateIndex(EventPtr event, size_t pos);
    void removeIndex(Event::EventID id);
};
```

### 关键方法实现

```cpp
void EventQueue::insert(EventPtr event) {
    heap_.push_back(event);
    size_t pos = heap_.size() - 1;
    updateIndex(event, pos);
    siftUp(pos);
    total_inserts_++;
}

EventPtr EventQueue::extractMin() {
    if (heap_.empty()) return nullptr;
    
    EventPtr min_event = heap_[0];
    removeIndex(min_event->getID());
    
    if (heap_.size() > 1) {
        heap_[0] = heap_.back();
        updateIndex(heap_[0], 0);
        heap_.pop_back();
        siftDown(0);
    } else {
        heap_.clear();
    }
    
    total_extracts_++;
    return min_event;
}

void EventQueue::remove(Event::EventID id) {
    auto it = id_to_pos_.find(id);
    if (it == id_to_pos_.end()) return;
    
    size_t pos = it->second;
    removeIndex(id);
    
    if (pos != heap_.size()) {
        heap_[pos] = heap_.back();
        heap_.pop_back();
        if (pos < heap_.size()) {
            updateIndex(heap_[pos], pos);
            siftDown(pos);
        }
    } else {
        heap_.pop_back();
    }
}
```

## 1.2.5 内存管理与性能

### 内存布局优化

二叉堆的内存布局对缓存性能影响很大：

```
连续内存布局(推荐):
heap = [event_0, event_1, event_2, event_3, ...]
       └─────────────────────────────────────┘
           一个连续内存块，缓存局部性好

分散指针布局(不推荐):
heap = [ptr_0, ptr_1, ptr_2, ptr_3, ...]
        │      │      │      │
        ▼      ▼      ▼      ▼
      [Event] [Event] [Event] [Event]  (分散在内存中)
```

**优化建议**:
1. 使用`std::vector`而非链表
2. 预留足够的容量避免频繁重新分配
3. 考虑使用内存池加速事件分配

### 缓存命中率分析

假设：
- L1缓存行大小: 64字节
- 每个事件对象大小: 48字节
- 缓存行可容纳事件数: 1-2个

```
访问模式: 从堆顶开始，逐层向下
├─ 访问堆[0] (命中)
├─ 访问堆[1], 堆[2] (可能命中，取决于位置)
├─ 访问堆[3], 堆[4], 堆[5], 堆[6] (命中率降低)
└─ ...

缓存命中率: 60-80% (取决于堆的深度和缓存策略)
```

### 内存分配建议

```cpp
class EventQueue {
public:
    // 预留容量，避免频繁重新分配
    void reserve(size_t capacity) {
        heap_.reserve(capacity);
    }
    
private:
    // 使用移动语义避免不必要的复制
    std::vector<EventPtr> heap_;
};

// 使用示例
EventQueue queue;
queue.reserve(1000000);  // 预留100万个事件的空间
for (auto& event : events) {
    queue.insert(event);  // 不会触发重新分配
}
```

## 1.2.6 多事件队列与并发

### 多队列策略

在多核环境中，可以使用多个队列减少锁竞争：

```
┌────────────────────────────────────┐
│      全局事件队列管理器            │
├────────────────────────────────────┤
│ Queue_0 │ Queue_1 │ Queue_2 │ ...  │
│ (线程0) │ (线程1) │ (线程2) │      │
└────────────────────────────────────┘
```

**优点**:
- 减少锁竞争
- 提高并发性能
- 可扩展到多核

**挑战**:
- 跨队列事件同步
- 全局时间管理复杂
- 潜在的顺序问题

### 无锁队列

也可使用无锁数据结构：

```cpp
// 使用第三方库(如boost::lockfree)
#include <boost/lockfree/queue.hpp>

boost::lockfree::queue<EventPtr> lockfree_queue;

// 线程安全的插入/提取，无需显式锁
lockfree_queue.push(event);
EventPtr evt;
lockfree_queue.pop(evt);
```

**权衡**:
- ✓ 高并发性能
- ✗ 实现复杂
- ✗ 调试困难

## 1.2.7 特殊事件类型

### 周期性事件

某些事件需要在固定间隔重复执行：

```cpp
class PeriodicEvent : public Event {
public:
    PeriodicEvent(uint64_t start, uint64_t period, 
                  Callback callback)
        : Event(start),
          period_(period),
          callback_(callback),
          execution_count_(0) {}
    
    void execute(EventScheduler& scheduler) override {
        callback_(scheduler);
        execution_count_++;
        
        // 重新安排下一次执行
        uint64_t next_time = time_ + period_;
        auto next_event = std::make_shared<PeriodicEvent>(
            next_time, period_, callback_
        );
        scheduler.scheduleEvent(next_event);
    }
    
private:
    uint64_t period_;
    Callback callback_;
    uint64_t execution_count_;
};
```

**应用场景**:
- 时钟周期事件(最常见)
- 定期刷新事件
- 轮询任务

### 延迟事件

某些事件在创建后一段时间才执行：

```cpp
// 创建一个在100个周期后执行的事件
auto event = std::make_shared<LambdaEvent>(
    current_time + 100,  // 延迟100个周期
    [](EventScheduler& scheduler) {
        // 执行逻辑
    }
);
scheduler.scheduleEvent(event);
```

## 1.2.8 事件队列的测试与验证

### 正确性测试

```cpp
// 测试1: 验证FIFO顺序
TEST(EventQueue, TimeOrdering) {
    EventQueue queue;
    
    // 乱序插入
    queue.insert(std::make_shared<Event>(100));
    queue.insert(std::make_shared<Event>(50));
    queue.insert(std::make_shared<Event>(150));
    queue.insert(std::make_shared<Event>(50));
    
    // 应该按时间顺序取出
    EXPECT_EQ(queue.extractMin()->getTime(), 50);
    EXPECT_EQ(queue.extractMin()->getTime(), 50);
    EXPECT_EQ(queue.extractMin()->getTime(), 100);
    EXPECT_EQ(queue.extractMin()->getTime(), 150);
}

// 测试2: 验证优先级顺序
TEST(EventQueue, PriorityOrdering) {
    EventQueue queue;
    
    // 同时刻的事件
    queue.insert(std::make_shared<Event>(100, 5));
    queue.insert(std::make_shared<Event>(100, 10));
    queue.insert(std::make_shared<Event>(100, 1));
    
    // 应该按优先级数降序取出
    EXPECT_EQ(queue.extractMin()->getPriority(), 10);
    EXPECT_EQ(queue.extractMin()->getPriority(), 5);
    EXPECT_EQ(queue.extractMin()->getPriority(), 1);
}
```

### 性能测试

```cpp
// 测试大规模事件
TEST(EventQueue, Performance) {
    EventQueue queue;
    const size_t N = 1000000;
    
    // 测试插入性能
    auto start = std::chrono::high_resolution_clock::now();
    for (size_t i = 0; i < N; i++) {
        queue.insert(std::make_shared<Event>(i));
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto insert_time = 
        std::chrono::duration_cast<std::chrono::milliseconds>(
            end - start).count();
    
    std::cout << "插入" << N << "个事件耗时: " 
              << insert_time << "ms\n";
    
    // 测试提取性能
    start = std::chrono::high_resolution_clock::now();
    while (!queue.empty()) {
        queue.extractMin();
    }
    end = std::chrono::high_resolution_clock::now();
    auto extract_time = 
        std::chrono::duration_cast<std::chrono::milliseconds>(
            end - start).count();
    
    std::cout << "提取" << N << "个事件耗时: " 
              << extract_time << "ms\n";
}
```

## 小结

本节详细分析了事件队列的设计与实现：

1. **二叉堆**是推荐的数据结构，所有操作都是O(log n)
2. **索引表**支持O(log n)的事件删除操作
3. **内存连续性**对缓存性能至关重要
4. **特殊事件类型**(如周期性事件)需要特殊处理
5. **正确性**和**性能**都需要仔细设计和测试

---

**关键代码位置**:
- `src/event.h`: Event和EventQueue的定义
- `src/scheduler.h`: EventScheduler中的队列实现

**下一小节**: [1.3 调度算法](./1.3-调度算法.md)
