# 1.3 调度算法

## 概述

调度算法决定了事件的执行顺序和模拟时间的推进。本节详细分析事件驱动模拟中的调度策略，包括基本调度算法、优先级管理、以及不同场景的优化方案。

## 1.3.1 基本调度算法

### 单线程事件循环

最简单的调度算法是单线程事件循环：

```cpp
class EventScheduler {
public:
    void run() {
        while (!event_queue_.empty()) {
            // 1. 从队列取最早事件
            EventPtr event = event_queue_.extractMin();
            
            // 2. 更新当前时间
            current_time_ = event->getTime();
            
            // 3. 执行事件
            if (!event->isCancelled()) {
                event->execute(*this);
            }
            
            // 4. 统计
            total_events_++;
        }
        
        // 模拟完成
        printStatistics();
    }
    
    void scheduleEvent(EventPtr event) {
        event_queue_.insert(event);
    }
    
private:
    EventQueue event_queue_;
    uint64_t current_time_;
    uint64_t total_events_;
};
```

**算法伪代码**:

```
function EventScheduler.run()
    while event_queue is not empty do
        event ← event_queue.extractMin()
        current_time ← event.time
        
        if not event.cancelled then
            event.execute(this)
        end if
        
        total_events ← total_events + 1
    end while
end function
```

### 时间复杂度分析

假设：
- 事件总数: E
- 系统组件数: N
- 平均事件执行时间: C

**事件驱动调度的复杂度**:

$$T_{event} = E \cdot (\log E + C) = O(E \log E)$$

其中：
- E·log E: 队列操作总成本
- E·C: 事件执行总成本

**循环驱动的复杂度**:

$$T_{cycle} = T_{max} \cdot N = O(T_{max} \cdot N)$$

其中T_max是最大模拟周期数

**性能对比**:

| 参数 | 循环驱动 | 事件驱动 |
|------|----------|----------|
| 事件总数E = 10M | - | 10M·log(10M)≈233M |
| 最大周期T = 1M | 1M·100 = 100M | - |
| 组件数N = 100 | - | - |
| **总操作数** | **100M** | **~233M + E·C** |

从上表可见，当C(执行成本)较小且E远小于T·N时，事件驱动更高效。

## 1.3.2 优先级调度

### 优先级定义

事件优先级由两部分组成：

```
Priority = (时间, 优先级号)

其中：
  - 时间 (uint64_t): 事件发生的逻辑时间，主排序键
  - 优先级号 (int): 同时刻事件的执行顺序，次排序键
                    范围: [0, 100], 越大优先级越高
```

### 优先级号的含义

优先级号用于指定同一时刻的执行顺序：

```
时刻100的事件列表：
  - 事件A: 优先级=90 (最后执行)
  - 事件B: 优先级=50 (中间执行)
  - 事件C: 优先级=99 (最先执行)

执行顺序: C (pri=99) → B (pri=50) → A (pri=90)
```

**通常的优先级号规范**:

| 范围 | 类型 | 说明 |
|------|------|------|
| 90-99 | 极高 | 系统事件，最高优先级 |
| 70-89 | 高 | 关键事件(中断、异常) |
| 50-69 | 中 | 普通计算事件 |
| 30-49 | 低 | 辅助事件 |
| 0-29 | 极低 | 统计、日志事件 |

### 优先级调度的实现

```cpp
class Event {
public:
    bool operator<(const Event& other) const {
        // 先按时间排序（早的优先）
        if (time_ != other.time_) {
            return time_ < other.time_;
        }
        // 时间相同时，按优先级号排序（高优先级先）
        return priority_ > other.priority_;
    }
};

// 使用优先级队列（最小堆）
std::priority_queue<EventPtr, 
                    std::vector<EventPtr>,
                    std::greater<EventPtr>> pq;
```

## 1.3.3 事件依赖与因果关系

### 事件依赖图

事件间的因果关系可用有向无环图(DAG)表示：

```
事件依赖示例：

    时间线 ───────────────────────────────────────────
    
    时刻10:  事件A (触发周期)
      │
      └──→ 时刻20: 事件B (由A产生)
            │
            ├──→ 时刻30: 事件C (流水线级) 
            │
            └──→ 时刻35: 事件D (执行结果)
    
    时刻15:  事件E (独立事件，与A/B无关)
      │
      └──→ 时刻25: 事件F
```

### 调度的正确性

关键保证：**事件必须按时间顺序执行**

```
如果 event_A.time < event_B.time，
则 event_A 必须在 event_B 之前执行
```

这个约束由优先级队列自动保证。

### 竞态条件的避免

由于事件驱动的单线程执行特性，不存在竞态条件：

```
✓ 事件执行是原子的
✓ 不存在中断或抢占
✓ 状态修改是确定的
✓ 结果可完全重现

正因如此，事件驱动模拟与并发系统的行为不同
```

## 1.3.4 时间推进策略

### 显式时间推进

时间不是连续推进的，而是跳跃到下一个事件时刻：

```
时间轴: 0  10  20  30  35  40  50  ...
        │   │   │   │   │   │   │
        ├───┤   │   │   │   │   │
        事件A-B链
            ├───┤   │   │   │   │
            事件C-D链
                    ├───┤   │   │
                    事件E
                        ├───┤   │
                        事件F
                            ├───┤
                            事件G
```

**优点**:
1. 跳过空闲时刻，加速模拟
2. 自动处理多时钟域
3. 逻辑清晰

**代码示例**:

```cpp
void EventScheduler::run() {
    while (!event_queue_.empty()) {
        // 显式更新时间到下一个事件时刻
        current_time_ = event_queue_.peek()->getTime();
        
        EventPtr event = event_queue_.extractMin();
        event->execute(*this);
    }
}
```

### 隐式时间推进

某些系统使用隐式时间推进（如SystemC）：

```cpp
// SystemC风格的隐式推进
sc_start();  // 自动推进到下一个事件
```

我们的框架采用**显式时间推进**，更易于理解和控制。

## 1.3.5 同步与内存模型

### 事件执行的内存可见性

事件驱动的单线程特性保证了内存可见性：

```cpp
Event A (time=10):
  component.state = 100;  // 修改状态

Event B (time=20):
  assert(component.state == 100);  // 保证可见
```

无需显式的volatile或fence操作，因为没有并发执行。

### 状态同步点

时间推进本身是一个隐式的同步点：

```
时刻T时的同步点：
  ├─ 所有时刻≤T的事件已完成
  ├─ 所有时刻>T的事件未开始
  └─ 系统处于一致的状态
```

## 1.3.6 调度算法的变体

### 变体1: 带超时的调度

```cpp
bool EventScheduler::runWithTimeout(uint64_t timeout_ms) {
    auto start = std::chrono::high_resolution_clock::now();
    
    while (!event_queue_.empty()) {
        // 检查超时
        auto elapsed = std::chrono::high_resolution_clock::now() - start;
        if (std::chrono::duration_cast<std::chrono::milliseconds>(
                elapsed).count() > timeout_ms) {
            return false;  // 超时，返回false
        }
        
        // 执行事件
        EventPtr event = event_queue_.extractMin();
        current_time_ = event->getTime();
        event->execute(*this);
    }
    
    return true;  // 正常完成
}
```

### 变体2: 带步进的调度

用于调试，允许逐步执行事件：

```cpp
class DebugEventScheduler : public EventScheduler {
public:
    bool step() {
        if (event_queue_.empty()) return false;
        
        EventPtr event = event_queue_.extractMin();
        current_time_ = event->getTime();
        
        std::cout << "Executing event: " 
                  << event->getName() 
                  << " at time " << current_time_ << "\n";
        
        event->execute(*this);
        return true;
    }
};

// 使用示例
DebugEventScheduler scheduler;
while (scheduler.step()) {
    // 逐步执行，可在此处设置断点
}
```

### 变体3: 快照与回滚

某些高级应用需要保存状态快照以支持回滚：

```cpp
class CheckpointEventScheduler : public EventScheduler {
private:
    struct Checkpoint {
        uint64_t time;
        SystemState state;
        size_t event_queue_size;
    };
    std::vector<Checkpoint> checkpoints_;
    
public:
    void saveCheckpoint(uint64_t time) {
        checkpoints_.push_back({
            time,
            captureSystemState(),
            event_queue_.size()
        });
    }
    
    void rollbackToCheckpoint(size_t idx) {
        // 恢复状态到指定检查点
        restoreSystemState(checkpoints_[idx].state);
        // 重建事件队列（需额外信息）
    }
};
```

## 1.3.7 调度的可视化与追踪

### 事件追踪

记录所有执行的事件便于分析：

```cpp
class TracingEventScheduler : public EventScheduler {
private:
    struct EventTrace {
        uint64_t id;
        uint64_t time;
        std::string name;
        uint64_t duration;  // 执行耗时
    };
    std::vector<EventTrace> traces_;
    
public:
    void run() override {
        while (!event_queue_.empty()) {
            auto start = std::chrono::high_resolution_clock::now();
            
            EventPtr event = event_queue_.extractMin();
            current_time_ = event->getTime();
            event->execute(*this);
            
            auto end = std::chrono::high_resolution_clock::now();
            uint64_t duration = 
                std::chrono::duration_cast<std::chrono::nanoseconds>(
                    end - start).count();
            
            // 记录追踪
            traces_.push_back({
                event->getID(),
                current_time_,
                event->getName(),
                duration
            });
        }
    }
    
    void printTrace() const {
        for (const auto& t : traces_) {
            std::cout << "Event " << t.id 
                      << ": " << t.name 
                      << " @ time " << t.time 
                      << " duration " << t.duration << "ns\n";
        }
    }
};
```

### 甘特图生成

追踪数据可用来生成甘特图：

```
时间 ═════════════════════════════════════════════════════
    ║
    0  Event_A [======]
       Event_E [=]
    
   10  Event_B [========]
       Event_C [==]
    
   20  Event_D [===]
       Event_F [====]
    
   30  Event_G [=]
```

## 1.3.8 调度的正确性验证

### 不变式检查

关键的不变式应在运行时检查：

```cpp
class VerifyingEventScheduler : public EventScheduler {
private:
    uint64_t last_event_time_ = 0;
    
    void verifyInvariants(const EventPtr& event) {
        // 不变式1: 时间单调递增
        assert(event->getTime() >= last_event_time_);
        
        // 不变式2: 优先级在有效范围内
        assert(event->getPriority() >= 0);
        assert(event->getPriority() <= 100);
        
        // 不变式3: 事件ID唯一
        assert(executed_events_.find(event->getID()) == 
               executed_events_.end());
    }
    
public:
    void run() override {
        while (!event_queue_.empty()) {
            EventPtr event = event_queue_.extractMin();
            
            verifyInvariants(event);
            
            current_time_ = event->getTime();
            event->execute(*this);
            
            last_event_time_ = event->getTime();
            executed_events_.insert(event->getID());
        }
    }
    
private:
    std::set<Event::EventID> executed_events_;
};
```

### 性能验证

```cpp
class PerformanceEventScheduler : public EventScheduler {
public:
    struct Stats {
        uint64_t total_events;
        uint64_t total_time_ns;
        double avg_time_per_event;
        double events_per_second;
    };
    
    Stats getStatistics() const {
        return {
            total_events_,
            total_time_ns_,
            static_cast<double>(total_time_ns_) / total_events_,
            static_cast<double>(total_events_) * 1e9 / total_time_ns_
        };
    }
};
```

## 小结

本节详细分析了调度算法：

1. **单线程事件循环**是基础调度方法
2. **优先级队列**确保正确的事件顺序
3. **时间复杂度**为O(E log E)，其中E是事件总数
4. **显式时间推进**跳过空闲周期
5. **多种变体**支持调试、追踪、验证

---

**下一小节**: [1.4 时间模型](./1.4-时间模型.md)
