# 1.4 时间模型

## 概述

时间是事件驱动模拟的核心维度。本节详细阐述时间模型、逻辑时间与物理时间的关系、多时钟域的处理，以及精确的时间戳管理。

## 1.4.1 逻辑时间与物理时间

### 时间的两个维度

```
┌─────────────────────────────────────────────────┐
│         时间的两个维度                          │
├─────────────────────────────────────────────────┤
│                                                 │
│  逻辑时间(Logical Time)   物理时间(Wall Time)   │
│  ├─ 模拟中的虚拟时间      ├─ 真实的执行时间     │
│  ├─ 单位: 周期(Cycle)     ├─ 单位: 纳秒(ns)    │
│  ├─ [0, max_cycle)        ├─ 取决于硬件性能    │
│  ├─ 模拟器控制            └─ 操作系统控制      │
│  └─ 与硬件无关                                 │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 逻辑时间

**定义**: 模拟器中的虚拟时间，用来衡量模拟进度

**单位**: 周期(Cycle)或时钟周期(Clock Period)

**范围**: 从0到模拟的最大周期数

```
示例: 模拟1GHz处理器
  逻辑时间=100周期
    ↓
  转换 (周期 × 时钟周期 = 100 × 1ns)
    ↓
  物理时间=100ns (仅用于显示，不影响模拟)
```

### 物理时间

**定义**: 模拟运行在计算机上消耗的真实时间

**单位**: 纳秒、毫秒、秒等

**获取方式**:

```cpp
#include <chrono>

auto start = std::chrono::high_resolution_clock::now();
// 执行模拟...
auto end = std::chrono::high_resolution_clock::now();
auto duration = std::chrono::duration_cast<
    std::chrono::milliseconds>(end - start).count();
```

### 两者的区别

| 维度 | 逻辑时间 | 物理时间 |
|------|----------|----------|
| 定义 | 模拟内的虚拟时间 | 真实的执行时间 |
| 控制权 | 模拟器 | 操作系统 |
| 确定性 | 完全确定 | 不确定，取决于系统负载 |
| 精度 | 周期精度 | 纳秒精度 |
| 推进方式 | 离散跳跃 | 连续推进 |

## 1.4.2 时间戳与事件时间

### 事件时间戳

每个事件都有一个时间戳，表示其发生的逻辑时刻：

```cpp
class Event {
private:
    uint64_t time_;  // 逻辑时间戳(周期)
    
public:
    uint64_t getTime() const { return time_; }
};
```

### 时间戳的产生

时间戳通常有三种来源：

1. **系统时钟事件**
```cpp
// 时钟产生的周期性事件
for (uint64_t cycle = 0; cycle < max_cycles; cycle++) {
    auto event = std::make_shared<ClockEvent>(cycle);
    scheduler.scheduleEvent(event);
}
```

2. **组件产生的事件**
```cpp
class ALU : public Component {
public:
    void execute(Instruction instr) {
        uint64_t completion_time = current_time + 3;  // 3个周期延迟
        auto event = std::make_shared<CompletionEvent>(
            completion_time,  // 时间戳
            instr
        );
        scheduler.scheduleEvent(event);
    }
};
```

3. **外部事件**
```cpp
// 模拟外部中断，例如在第1000个周期发生
auto interrupt_event = std::make_shared<InterruptEvent>(1000);
scheduler.scheduleEvent(interrupt_event);
```

### 时间戳的有效性

时间戳必须满足：

```
valid_timestamp(t) ⟺ t ≥ current_time

原因:
  ✓ 不能创建过去的事件(会改变历史)
  ✓ 可以创建当前或未来的事件
  ✓ 同时刻事件需要用优先级号区分
```

## 1.4.3 多时钟域的时间管理

### 多时钟域的定义

现代SoC(片上系统)通常有多个时钟域，各自独立运行：

```
┌──────────────────────────────────────────────────┐
│              系统时钟树                          │
├──────────────────────────────────────────────────┤
│                                                  │
│  主时钟(Main Clock)                              │
│  f_main = 2 GHz, T_main = 0.5 ns                │
│  │                                              │
│  ├─→ 核心时钟域(Core Domain)                    │
│  │   f_core = 2 GHz, T_core = 0.5 ns           │
│  │   (与主时钟同频)                             │
│  │                                              │
│  ├─→ 内存时钟域(Memory Domain)                 │
│  │   f_mem = 1 GHz, T_mem = 1.0 ns             │
│  │   (降频2倍)                                  │
│  │                                              │
│  └─→ I/O时钟域(I/O Domain)                      │
│      f_io = 500 MHz, T_io = 2.0 ns             │
│      (降频4倍)                                  │
│                                                  │
└──────────────────────────────────────────────────┘
```

### 频率转换

在统一的逻辑时间中，不同域的周期转换：

```
设参考时钟为f_ref (GHz)，转换公式:

任何事件的逻辑时间都以最小的时钟周期为单位
这样可以统一表示所有时钟域的事件

例如，若f_ref = 2 GHz (最高频率)

核心域 (2 GHz):  逻辑时间 = t_core × 1
内存域 (1 GHz):  逻辑时间 = t_mem × 2
I/O域 (500MHz): 逻辑时间 = t_io × 4
```

### 多时钟域的实现

```cpp
class MultiClockScheduler : public EventScheduler {
private:
    // 时钟域信息
    struct ClockDomain {
        std::string name;
        uint64_t frequency_mhz;  // MHz为单位
        uint64_t period_ps;      // 时钟周期，单位皮秒(ps)
        uint64_t local_time;     // 本域的本地时间
    };
    
    std::map<std::string, ClockDomain> domains_;
    uint64_t reference_time_;   // 统一的参考时间
    
public:
    void addClockDomain(const std::string& name,
                        uint64_t frequency_mhz) {
        uint64_t period_ps = 1000000000UL / frequency_mhz;
        domains_[name] = {name, frequency_mhz, period_ps, 0};
    }
    
    uint64_t localTimeToLogicalTime(
        const std::string& domain,
        uint64_t local_time) const {
        // 将某个域的本地时间转换为逻辑时间
        auto it = domains_.find(domain);
        if (it == domains_.end()) return 0;
        
        // 找到最小周期域(参考域)
        uint64_t min_period = UINT64_MAX;
        for (const auto& [name, dom] : domains_) {
            min_period = std::min(min_period, dom.period_ps);
        }
        
        // 逻辑时间 = 物理时间 / 最小周期
        uint64_t physical_time = local_time * it->second.period_ps;
        return physical_time / min_period;
    }
};
```

### 多域事件的例子

```cpp
// 场景: 核心完成计算，向内存控制器发送请求

// 时刻1: 核心(2GHz)在第100个周期产生事件
uint64_t core_time = 100;
uint64_t logical_time_100 = core_time * 1;  // 100

auto mem_request = std::make_shared<MemoryRequestEvent>(
    logical_time_100,
    request_data
);
scheduler.scheduleEvent(mem_request);

// 时刻2: 内存控制器(1GHz)处理请求，延迟为10个内存周期
// 内存周期 = 逻辑时间 × 2 (因为内存频率是核心的一半)
uint64_t mem_latency_logical = 10 * 2;  // 20个逻辑周期

auto mem_response = std::make_shared<MemoryResponseEvent>(
    logical_time_100 + mem_latency_logical,  // 时刻120
    response_data
);
scheduler.scheduleEvent(mem_response);
```

## 1.4.4 时间精度问题

### 精度等级

```
┌──────────────────────────────────────────┐
│      逻辑时间的精度等级                  │
├──────────────────────────────────────────┤
│                                          │
│  1. 周期精度(Cycle Level) ✓ 默认选项     │
│     - 单位: 1个时钟周期                  │
│     - 最常用的粒度                       │
│     - 足以描述大多数硬件行为            │
│                                          │
│  2. 子周期精度(Sub-Cycle)                │
│     - 单位: 时钟周期的分数               │
│     - 用于微结构级模拟                   │
│     - 实现复杂，性能代价大              │
│                                          │
│  3. 纳秒精度(Nanosecond)                 │
│     - 使用浮点数表示                     │
│     - 容易出现舍入误差                   │
│     - 不推荐                             │
│                                          │
└──────────────────────────────────────────┘
```

### 精度陷阱与避免

**陷阱1: 浮点数导致的舍入误差**

```cpp
// ❌ 错误: 使用浮点数
double logical_time = 1.5;  // 模糊不清
double new_time = logical_time + 0.1;
// 可能产生舍入误差: 1.6000000000001

// ✓ 正确: 使用整数
uint64_t logical_time = 15;  // 表示1.5个时钟周期(×10)
uint64_t new_time = logical_time + 1;  // 1.6个周期
```

**陷阱2: 单位转换导致的精度丧失**

```cpp
// ❌ 错误: 转换导致精度丧失
uint64_t nanoseconds = 333;     // 333ns
uint64_t cycles = nanoseconds / 500;  // 除以0.5ns周期
// 结果: 666.0，但如果用整数除法: 666(丧失精度)

// ✓ 正确: 保持统一单位或用高精度单位
uint64_t picoseconds = 333000;  // 333000ps
uint64_t cycles = picoseconds / 500;  // 500ps周期
// 结果: 666, 精确
```

### 精度的选择

```cpp
// 推荐: 使用整数周期作为基本单位
class Event {
public:
    // 使用uint64_t表示周期数
    // 足以表示超过1000年的模拟(在GHz频率下)
    uint64_t time_;  
    
    // 对于需要亚周期精度的应用，使用倍增单位
    // 例如，若需要0.1周期精度，可乘以10
    uint64_t time_10x_;  // 1个单位 = 0.1周期
};
```

## 1.4.5 时间同步与检查点

### 时间同步点

在模拟中，某些时刻是关键的**同步点**：

```
时刻T是一个同步点，意味着:
  ✓ 所有时刻 ≤ T 的事件已完成执行
  ✓ 所有时刻 > T 的事件未开始执行
  ✓ 系统处于一致(Consistent)的状态
```

### 检查点保存

定期保存系统状态快照：

```cpp
class CheckpointManager {
private:
    struct Checkpoint {
        uint64_t logical_time;
        SystemState state;
        std::vector<EventPtr> pending_events;
    };
    std::map<uint64_t, Checkpoint> checkpoints_;
    
public:
    void saveCheckpoint(uint64_t time, const SystemState& state) {
        checkpoints_[time] = {
            time,
            state,
            // 保存待处理事件列表
            event_queue_.getAllEvents()
        };
    }
    
    void restoreCheckpoint(uint64_t time) {
        auto it = checkpoints_.find(time);
        if (it != checkpoints_.end()) {
            // 恢复系统状态
            restoreSystemState(it->second.state);
            // 重建事件队列
            rebuildEventQueue(it->second.pending_events);
        }
    }
};
```

## 1.4.6 时间相关的常见错误

### 错误1: 时间倒流

```cpp
// ❌ 错误: 时间倒流(不被允许)
for (const auto& event : events) {
    if (event->time_ < current_time_) {
        // 试图执行一个过去的事件
        // 这会导致模拟状态不一致
        event->execute();  // 错误!
    }
}

// ✓ 正确: 时间单调递增
void EventScheduler::run() {
    while (!event_queue_.empty()) {
        auto event = event_queue_.extractMin();
        assert(event->time_ >= current_time_);  // 确保时间递增
        current_time_ = event->time_;
        event->execute(*this);
    }
}
```

### 错误2: 时间混淆

```cpp
// ❌ 错误: 混淆两种时间
uint64_t start = std::chrono::system_clock::now()
    .time_since_epoch().count();  // 物理时间

scheduler.run();

uint64_t end = std::chrono::system_clock::now()
    .time_since_epoch().count();

// 错误地计算逻辑时间
uint64_t simulated_cycles = end - start;  // 这是物理时间差!
```

**正确做法**:

```cpp
// ✓ 正确: 分离逻辑时间和物理时间
auto physical_start = std::chrono::high_resolution_clock::now();

uint64_t logical_start = 0;
scheduler.run();
uint64_t logical_end = scheduler.getCurrentTime();

auto physical_end = std::chrono::high_resolution_clock::now();

uint64_t simulated_cycles = logical_end - logical_start;
auto physical_elapsed = 
    std::chrono::duration_cast<std::chrono::milliseconds>(
        physical_end - physical_start);

std::cout << "Simulated: " << simulated_cycles << " cycles\n"
          << "Physical time: " << physical_elapsed.count() << "ms\n";
```

### 错误3: 时间精度不足

```cpp
// ❌ 错误: 精度不足导致事件丢失
uint32_t time_;  // 仅32位，最多4B周期(~2秒@2GHz)

// ✓ 正确: 使用足够的位宽
uint64_t time_;  // 64位，足以支持超长模拟
```

## 1.4.7 性能与时间模型

### 模拟速度度量

模拟速度通常用**KIPS**(千周期每秒)或**MIPS**表示：

```
KIPS = 模拟周期数 / 物理时间(秒) / 1000
MIPS = 模拟周期数 / 物理时间(秒) / 1000000

例如:
  模拟100万个周期耗时0.1秒
  MIPS = 1,000,000 / 0.1 / 1,000,000 = 10 MIPS
```

### 时间模型对性能的影响

```
┌─────────────────────────────┐
│   时间精度 vs 模拟性能      │
├─────────────────────────────┤
│                             │
│ 周期精度:    ▰▰▰▰▰ 最快     │
│             (小常数因子)     │
│                             │
│ 亚周期精度:  ▰▰▰ 较慢       │
│             (中等开销)       │
│                             │
│ 纳秒精度:    ▰ 最慢        │
│             (浮点操作)       │
│                             │
└─────────────────────────────┘
```

## 小结

本节详细阐述了时间模型：

1. **逻辑时间**是模拟器内的虚拟时间，以周期为单位
2. **物理时间**是实际执行时间，与逻辑时间独立
3. **多时钟域**通过频率转换统一到逻辑时间
4. **时间精度**应选择整数周期，避免浮点误差
5. **常见错误**包括时间倒流、混淆两种时间等

---

**下一小节**: [1.5 性能考量](./1.5-性能考量.md)
