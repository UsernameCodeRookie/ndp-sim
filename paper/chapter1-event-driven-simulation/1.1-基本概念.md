# 1.1 基本概念

## 概述

事件驱动离散事件模拟(Discrete Event Simulation, DES)是现代计算机模拟的基础范式。本节系统介绍事件驱动模拟的核心概念，为后续章节奠定理论基础。

## 1.1.1 事件驱动模拟的基本思想

### 定义

**事件驱动模拟**是一种模拟方法，其中：
- 系统的演进由一系列离散事件驱动
- 事件在特定的逻辑时间点发生
- 事件的执行可能产生新的事件
- 模拟按事件时间顺序进行，而非按固定周期进行

### 核心特征

1. **事件驱动性**: 模拟主动权掌握在事件手中，而非固定的时钟
2. **离散性**: 状态变化发生在离散的时间点，时间点间系统状态不变
3. **异步性**: 事件可在任意时间发生，无需同步到固定周期
4. **确定性**: 给定相同的初始状态和事件序列，结果必然相同

### 应用场景

事件驱动模拟特别适用于以下场景：

| 场景 | 原因 | 示例 |
|------|------|------|
| 事件稀疏系统 | 大量空闲周期可跳过 | 中断处理、异步I/O |
| 多时钟域 | 不同域各自推进 | SoC、异构计算 |
| 长时间模拟 | 大幅减少模拟步数 | 长期行为分析 |
| 大规模系统 | 可扩展到多核 | 数据中心模拟 |

## 1.1.2 事件驱动 vs 循环驱动

### 循环驱动的工作流程

循环驱动(Cycle-by-Cycle)是最简单的模拟方法：

```python
time = 0
while time < max_time:
    for each_component in system.components:
        each_component.tick(time)
    time += 1
```

**特点**：
- ✓ 实现简单，容易理解
- ✓ 与硬件时钟同步，直观
- ✗ 即使系统空闲也要执行
- ✗ 大规模系统扩展性差

**时间复杂度**: O(T × N)，其中T是模拟周期数，N是组件数

### 事件驱动的工作流程

```python
event_queue = PriorityQueue()
event_queue.enqueue(initial_event)

while event_queue is not empty:
    event = event_queue.dequeue()  # 取最早事件
    current_time = event.time
    event.execute(event_queue)     # 可能产生新事件
```

**特点**：
- ✓ 跳过空闲周期，效率高
- ✓ 自然支持多时钟域
- ✓ 可扩展性好
- ✗ 实现复杂度高
- ✗ 需要精细的事件管理

**时间复杂度**: O(E × log E)，其中E是总事件数

### 定量对比分析

考虑一个模拟场景：
- 模拟周期数: T = 1,000,000
- 系统组件数: N = 100
- 平均每周期活跃事件: 10

**循环驱动**: 
- 操作次数 = 1,000,000 × 100 = 100,000,000

**事件驱动**:
- 总事件数 = 1,000,000 × 10 = 10,000,000
- 队列操作 = 10,000,000 × log(10,000,000) ≈ 230,000,000

在这个例子中，事件驱动的优势在于：
- 避免了90%的空闲周期处理
- 虽然队列操作成本较高，但总体仍然更优
- 系统活跃度越低，优势越明显

## 1.1.3 事件的定义

### 事件的构成

一个事件由以下要素组成：

```
Event = {
    time: 发生时刻 (uint64_t),
    priority: 优先级 (int),
    type: 事件类型 (enum),
    id: 唯一标识 (uint64_t),
    payload: 携带数据 (any),
    handler: 处理函数 (callable)
}
```

### C++实现示例

```cpp
class Event {
public:
    using EventID = uint64_t;
    
    Event(uint64_t time, int priority = 0, 
          EventType type = EventType::GENERIC,
          const std::string& name = "Event")
        : time_(time),
          priority_(priority),
          type_(type),
          name_(name),
          id_(next_id_++),
          cancelled_(false) {}
    
    // 虚函数，由具体事件子类实现
    virtual void execute(EventScheduler& scheduler) = 0;
    
    // Getter方法
    uint64_t getTime() const { return time_; }
    int getPriority() const { return priority_; }
    
private:
    uint64_t time_;
    int priority_;
    EventType type_;
    std::string name_;
    EventID id_;
    bool cancelled_;
    static EventID next_id_;
};
```

### 事件类型

不同的事件可归为不同类型，便于分类和统计：

```cpp
enum class EventType {
    GENERIC,          // 通用事件
    COMPUTE,          // 计算事件
    MEMORY_ACCESS,    // 内存访问
    COMMUNICATION,    // 通信事件
    CUSTOM            // 用户自定义
};
```

## 1.1.4 事件队列的概念

### 定义

**事件队列**是一个优先级队列，存储所有待执行的事件，按时间顺序排列。

```
事件队列 = { event_1, event_2, ..., event_n }
其中: event_1.time ≤ event_2.time ≤ ... ≤ event_n.time
```

### 关键性质

1. **有序性**: 队列中事件始终按时间排序
2. **高效性**: 应支持O(log n)的插入和删除
3. **正确性**: 确保事件按时间顺序执行
4. **可扩展性**: 支持大量事件（百万级）

### 队列操作

事件队列需支持的基本操作：

| 操作 | 说明 | 复杂度 |
|------|------|--------|
| Insert | 插入新事件 | O(log n) |
| ExtractMin | 提取最早事件 | O(log n) |
| Delete | 删除指定事件 | O(log n) |
| DecreaseKey | 修改事件时间 | O(log n) |
| Empty | 检查是否为空 | O(1) |

## 1.1.5 事件驱动调度器的架构

### 逻辑结构

事件驱动调度器的逻辑结构如下：

```
┌─────────────────────────────────────┐
│     EventScheduler(调度器)          │
├─────────────────────────────────────┤
│ ┌─────────────────────────────────┐ │
│ │ Event Queue (优先级队列)        │ │
│ │ - 存储所有待执行事件            │ │
│ │ - 按时间排序                    │ │
│ └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│ ┌─────────────────────────────────┐ │
│ │ Time Management (时间管理)      │ │
│ │ - 当前逻辑时间                  │ │
│ │ - 时间戳维护                    │ │
│ └─────────────────────────────────┘ │
├─────────────────────────────────────┤
│ ┌─────────────────────────────────┐ │
│ │ Statistics (统计信息)           │ │
│ │ - 已执行事件数                  │ │
│ │ - 性能指标                      │ │
│ └─────────────────────────────────┘ │
└─────────────────────────────────────┘
```

### 调度循环

```
loop {
    1. 检查事件队列是否为空
       ├─ 为空: 模拟完成，退出循环
       └─ 非空: 继续

    2. 从队列中取出最早事件
       time = event.time
       priority = event.priority

    3. 更新当前时间
       current_time = time

    4. 执行事件
       event.execute(scheduler)
       ├─ 可能产生新事件
       ├─ 新事件被加入队列
       └─ 状态被修改

    5. 处理统计信息
       event_count++
}
```

### C++实现框架

```cpp
class EventScheduler {
private:
    std::priority_queue<Event> event_queue_;
    uint64_t current_time_;
    uint64_t event_count_;

public:
    void run() {
        while (!event_queue_.empty()) {
            // 取最早事件
            Event event = event_queue_.top();
            event_queue_.pop();
            
            // 更新时间
            current_time_ = event.getTime();
            
            // 执行事件
            if (!event.isCancelled()) {
                event.execute(*this);
            }
            
            // 更新统计
            event_count_++;
        }
    }
    
    void scheduleEvent(std::shared_ptr<Event> event) {
        event_queue_.push(event);
    }
    
    uint64_t getCurrentTime() const {
        return current_time_;
    }
};
```

## 1.1.6 事件执行模型

### 事件执行的三个阶段

```
Phase 1: 事件触发前
  ├─ 初始状态: current_time = T_before
  └─ 队列状态: event在队列中

Phase 2: 事件执行（原子操作）
  ├─ 执行事件的execute()方法
  ├─ 可能修改系统状态
  ├─ 可能向队列添加新事件
  └─ 不存在中断或抢占

Phase 3: 事件执行后
  ├─ 更新时间: current_time = T_after
  └─ 新事件已入队
```

### 事件原子性

一个关键假设是**事件执行的原子性**：

```
✓ 假设：事件执行过程中不会有其他事件执行
✓ 结果：事件间没有竞态(Race Condition)
✓ 推论：确定性结果
```

这是事件驱动模拟与并发系统的重要区别。

### Lambda事件支持

为了方便，框架支持使用Lambda函数定义事件：

```cpp
// 方式1: 继承Event类
class MyEvent : public Event {
    void execute(EventScheduler& scheduler) override {
        // 自定义逻辑
    }
};

// 方式2: 使用LambdaEvent
scheduler.scheduleEvent(
    std::make_shared<LambdaEvent>(
        time, 
        [](EventScheduler& scheduler) {
            // 自定义逻辑
        },
        priority,
        "MyEvent"
    )
);
```

## 1.1.7 与物理时间的关系

### 逻辑时间 vs 物理时间

```
逻辑时间(Logical Time):
  - 模拟中的虚拟时间
  - 单位: 周期(Cycle)
  - 范围: [0, max_cycle)
  - 与实际执行时间无关

物理时间(Physical Time):
  - 真实的执行时间
  - 单位: 纳秒(ns), 微秒(μs)等
  - 范围: 取决于硬件性能
  - 与逻辑时间的映射关系可变
```

### 转换公式

假设处理器时钟频率为f(GHz)，则时钟周期为T(ns)，转换关系为：

$$\text{物理时间(ns)} = \text{逻辑时间(周期)} \times \text{时钟周期(ns)}$$

**例子**：
- 时钟频率: 2 GHz
- 时钟周期: 0.5 ns
- 逻辑时间: 1000 周期
- 物理时间: 1000 × 0.5 = 500 ns

### 混合时间模型

在多时钟域系统中，可能需要混合时间模型：

```
处理器核心: 2 GHz (0.5 ns周期)
内存: 1 GHz (1.0 ns周期)
I/O: 500 MHz (2.0 ns周期)

逻辑时间 = 100周期 @处理器
        = 50周期 @内存
        = 25周期 @I/O
```

## 1.1.8 事件驱动的优缺点总结

### 优点

1. **效率高**
   - 跳过空闲周期
   - 稀疏事件下大幅加速
   - 特别适合中断密集型系统

2. **可扩展性好**
   - 自然支持多时钟域
   - 易于扩展到多核
   - 模块化程度高

3. **灵活性强**
   - 事件可在任意时间发生
   - 优先级机制灵活
   - 易于模拟复杂行为

4. **确定性强**
   - 结果可复现
   - 便于调试和验证
   - 支持事件回放和记录

### 缺点

1. **实现复杂**
   - 需要精细的事件管理
   - 需要正确的优先级设计
   - 易出现微妙的时序bug

2. **性能开销**
   - 队列操作有额外成本
   - 内存管理开销
   - 动态事件生成的成本

3. **调试困难**
   - 事件顺序非线性
   - 时序bug难以重现
   - 需要好的跟踪工具

4. **学习曲线陡**
   - 概念较为抽象
   - 需要深入理解时序
   - 优先级设置需要经验

## 1.1.9 事件驱动适用性评估

### 决策树

```
是否考虑事件驱动?
  |
  ├─ 需要高精度时序模拟?
  |    ├─ 是 → 考虑事件驱动
  |    └─ 否 → 循环驱动足够
  |
  ├─ 系统事件是否稀疏?
  |    ├─ 是 → 强烈推荐事件驱动
  |    └─ 否 → 权衡利弊
  |
  ├─ 是否有多个时钟域?
  |    ├─ 是 → 推荐事件驱动
  |    └─ 否 → 两者皆可
  |
  └─ 模拟规模是否很大?
       ├─ 是 → 推荐事件驱动
       └─ 否 → 循环驱动更简单
```

### 适用指标表

| 指标 | 轻 | 中 | 重 |
|------|----|----|-----|
| 活跃度 | <5% | 5-30% | >30% |
| 推荐方法 | 事件驱动 | 根据实际 | 循环驱动 |
| 性能收益 | 20×+ | 5-20× | <5× |

## 小结

本节介绍了事件驱动模拟的基本概念：

1. **事件驱动**是一种模拟方法，以事件发生驱动模拟进程
2. **事件队列**是其核心数据结构，按时间有序存储待执行事件
3. **优先级机制**确保同时刻事件的正确顺序
4. **逻辑时间**与物理时间通过时钟周期相关联
5. 事件驱动在**事件稀疏**和**多时钟域**场景中特别高效

---

**关键术语回顾**:
- 事件(Event): 在特定时刻发生的原子动作
- 事件队列: 优先级队列，存储待执行事件
- 逻辑时间: 模拟中的虚拟时间
- 优先级: 同时刻事件的执行顺序
- 事件驱动: 由事件主动推进的模拟方法

**下一小节**: [1.2 事件队列设计](./1.2-事件队列设计.md)
