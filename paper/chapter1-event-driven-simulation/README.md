# 第一章 事件驱动模拟原理与调度方法

## 章节概述

本章深入阐述事件驱动离散事件模拟(Discrete Event Simulation, DES)的核心原理与实现方法。事件驱动模拟是现代计算机体系结构模拟的主流方法，相比传统的循环驱动(cycle-by-cycle)模拟，它具有更高的效率和更好的扩展性。

**本章主要内容**:
- 事件驱动模拟的基本概念
- 事件队列的设计与实现
- 调度算法与时间复杂度分析
- 时间模型与同步机制
- 性能优化考量
- 实际应用案例分析

**本章字数**: 约25,000字

## 主要小节列表

| 小节 | 标题 | 字数 |
|------|------|------|
| 1.1 | [基本概念](./1.1-基本概念.md) | 3000 |
| 1.2 | [事件队列设计](./1.2-事件队列设计.md) | 4500 |
| 1.3 | [调度算法](./1.3-调度算法.md) | 5000 |
| 1.4 | [时间模型](./1.4-时间模型.md) | 4500 |
| 1.5 | [性能考量](./1.5-性能考量.md) | 4000 |
| 1.6 | [案例分析](./1.6-案例分析.md) | 4000 |

## 学习路径

### 快速入门路径
1. 阅读1.1基本概念，理解事件驱动的核心思想
2. 浏览1.2事件队列设计，了解数据结构选择
3. 直接跳转第二章学习建模框架

### 深入学习路径
1. 完整阅读1.1-1.4各小节
2. 理解时间复杂度分析（1.3、1.5）
3. 通过1.6案例分析加深理解

### 优化与应用路径
1. 重点关注1.5性能考量
2. 深入研究1.6案例分析
3. 考虑自己的应用场景

## 核心概念预览

### 事件驱动 vs 循环驱动

**循环驱动（Cycle-by-Cycle）**:
```
for cycle in 0..max_cycles:
    for component in all_components:
        component.tick()
```
- 简单直观
- 适合紧密耦合的设计
- 每个周期都执行，即使没有活动

**事件驱动（Event-Driven）**:
```
while event_queue is not empty:
    event = event_queue.get_next()
    event.execute()
    // 可能产生新事件
```
- 只在有活动时执行
- 更高效处理稀疏事件
- 自然支持多时钟域

### 事件队列的抽象表示

事件队列本质上是一个优先级队列，按以下优先级排序：

$$\text{优先级} = (时间, 优先级编号)$$

其中时间是主排序键，优先级编号是次排序键。

### 时间模型

事件驱动模拟中使用**逻辑时间**而非物理时间：

$$\text{逻辑时间} = \text{周期数} \times \text{时钟周期(物理时间)}$$

例如，在1ns时钟周期的1GHz处理器上：
- 逻辑时间=100个周期 → 物理时间=100ns

## 第一章的阅读指南

### 面向不同角色的学习建议

**硬件设计师**:
- 关键关注: 1.1, 1.2, 1.3
- 重点理解: 事件优先级的管理
- 应用场景: 多时钟域同步

**软件开发者**:
- 关键关注: 1.1, 1.2, 1.3, 1.5
- 重点理解: 队列性能与内存
- 应用场景: 模拟性能优化

**研究者**:
- 关键关注: 全部小节
- 重点理解: 与其他模拟方法的对比
- 应用场景: 创新模拟算法

## 关键问题

本章力图回答以下关键问题：

1. **为什么使用事件驱动而非循环驱动?**
   - 答: 在事件稀疏的场景中，事件驱动可显著降低模拟时间
   - 详见: 1.1, 1.5

2. **如何确保事件的正确顺序?**
   - 答: 通过优先级队列维持时间顺序
   - 详见: 1.2, 1.3

3. **事件优先级如何设置?**
   - 答: 按时间主排序，优先级号次排序
   - 详见: 1.3, 1.4

4. **如何处理同时刻的多个事件?**
   - 答: 通过优先级号确定执行顺序
   - 详见: 1.4

5. **事件驱动模拟的性能瓶颈是什么?**
   - 答: 事件队列操作和内存管理
   - 详见: 1.5

6. **如何优化事件驱动模拟?**
   - 答: 批量事件处理、缓存优化等
   - 详见: 1.5, 1.6

## 核心术语表

| 术语 | 定义 | 首次出现 |
|------|------|---------|
| 事件(Event) | 在特定逻辑时间发生的原子动作 | 1.1 |
| 事件队列 | 按时间顺序排列的待执行事件 | 1.2 |
| 优先级队列 | 支持高效取最小(最大)元素的队列 | 1.2 |
| 事件驱动 | 根据事件主动推进模拟的方法 | 1.1 |
| 循环驱动 | 按周期顺序执行所有组件 | 1.1 |
| 逻辑时间 | 模拟中的虚拟时间，单位为周期 | 1.4 |
| 物理时间 | 真实的时钟时间 | 1.4 |
| 优先级数 | 同一时刻不同事件的顺序号 | 1.3 |
| 时间复杂度 | 随输入规模增长的计算成本 | 1.3 |
| 空间复杂度 | 随输入规模增长的内存成本 | 1.5 |

## 代码实现概览

本论文的所有概念都有对应的C++实现，主要位于:
- `src/event.h`: 事件类定义
- `src/scheduler.h`: 事件调度器实现
- `src/tick.h`: 时钟周期管理

## 与后续章节的关系

```
第一章: 事件驱动基础
    ↓
第二章: 使用事件驱动进行体系结构建模
    ↓
第三章: 具体建模Coral NPU处理器
```

第二章将在事件驱动的基础上，介绍如何设计Port、Component等抽象来建模体系结构。第三章则展示如何将这些抽象应用于实际处理器的建模。

## 推荐阅读顺序

1. **初学者**: 1.1 → 1.2 → 1.3 → 跳转第二章
2. **工程师**: 1.1 → 1.2 → 1.3 → 1.5 → 根据需要查阅其他部分
3. **研究者**: 完整阅读 1.1 → 1.6

---

**下一小节**: [1.1 基本概念](./1.1-基本概念.md)
