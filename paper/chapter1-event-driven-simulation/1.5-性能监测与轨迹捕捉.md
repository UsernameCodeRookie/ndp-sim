# 1.5 性能监测与轨迹捕捉

## 1.4.1 性能指标的系统采集

性能监测是模拟器的重要功能，用于理解系统的行为和性能特征。但如何高效地收集性能数据而不过度影响模拟速度，是一个重要问题。

**常见的性能指标**：

- **事件统计**：总事件数、事件类型分布、事件大小分布
- **时间统计**：模拟总时长、首个/末个事件的时刻、事件发生频率
- **队列统计**：队列平均大小、最大大小、队列峰值时刻
- **性能指标**：真实执行时间（wall-clock time）、模拟速度（周期/秒）、事件处理吞吐量

**性能监测的分层**：

性能监测可以分为多个层次：

1. **框架级监测**：事件队列、调度器的统计
2. **组件级监测**：各个组件的内部状态和活跃度
3. **系统级监测**：整个系统的全局行为和性能指标

不同层次的监测有不同的成本。框架级监测通常成本最低（几个原子操作），而系统级监测可能需要复杂的计算。

**增量统计的技巧**：

对于某些统计指标，如平均值，可以使用增量计算的方法避免反复累加：

$$\text{均值} = \frac{\text{旧均值} \times N + \text{新值}}{N+1}$$

这样每次只需要常数时间更新，而不需要重新遍历所有历史值。

## 1.4.2 轨迹捕捉与重放

轨迹（Trace）是模拟执行过程中的记录。它记录了模拟进行的关键事件和时刻。轨迹对于调试和分析非常有价值。

**轨迹的内容**：

轨迹通常包含：

- **时刻戳**（Timestamp）：事件发生的逻辑时刻
- **事件类型**（Event Type）：事件的分类
- **事件内容**（Event Content）：事件的详细信息
- **状态信息**（State）：事件发生时的系统状态

例如，一个指令执行的轨迹可能包含：

```
[时刻500] FetchEvent: PC=0x1000, instruction=add r1, r2, r3
[时刻501] DecodeEvent: opcode=ADD, src1=r2, src2=r3, dest=r1
[时刻502] ExecuteEvent: ALU_input1=10, ALU_input2=20, result=30
[时刻503] WritebackEvent: reg_r1=30, ready=true
```

**轨迹的采集方法**：

采集轨迹的基本方法是在事件执行时，将关键信息写入文件或内存缓冲区：

```cpp
void EventScheduler::executeEvent(Event* event) {
    if (tracing_enabled) {
        tracer.record(current_time, event->type, event->data);
    }
    event->execute();
}
```

为了减少开销，轨迹采集通常只记录关键事件，而不是所有事件。这可以通过事件类型过滤或采样实现。

**轨迹压缩**：

完整的轨迹可能非常大。对于长时间的模拟，轨迹大小可能达到数GB甚至数TB。压缩是必要的。

常用的压缩方法：

- **增量编码**：只记录与上一个值的差异
- **模式识别**：识别重复的模式，用符号代替
- **数据类型优化**：使用更紧凑的数据表示（如uint16代替uint64当可能时）

## 1.4.3 瓶颈识别与性能分析

性能数据的目标是识别系统的性能瓶颈。

**关键性能指标的定义**：

- **CPI（Cycles Per Instruction）**：平均每条指令耗费的周期数。值越小越好
- **缓存命中率**：访存中L1缓存命中的比例。通常目标是>90%
- **执行单元利用率**：执行单元被使用的比例。目标是>80%
- **内存带宽利用率**：实际使用的内存带宽占最大带宽的比例

**瓶颈定位的方法**：

通过对比这些指标的理想值和实际值，可以识别瓶颈：

1. **如果CPI远高于理想值**：说明存在指令依赖或流水线停顿
2. **如果缓存命中率低**：说明存在容量缺失或冲突缺失
3. **如果执行单元利用率低**：说明指令级并行性不足
4. **如果内存带宽利用率低**：说明存在访存延迟或预取不足

**临界路径分析**：

对于复杂系统，临界路径（最长依赖链）往往是性能的限制因素。可以通过构建依赖图，识别最长的依赖链，进而优化该链上的关键路径延迟。

## 1.4.4 调试支持与断点机制

事件驱动模拟器需要提供强大的调试支持。

**事件级断点**：

可以在特定事件上设置断点：

```cpp
scheduler.setBreakpoint(EventType::INSTRUCTION_EXECUTE, PC=0x1000);
```

当满足条件的事件发生时，模拟器暂停并进入交互式调试模式。

**条件式断点**：

更复杂的调试可能需要条件式断点：

```cpp
scheduler.setConditionalBreakpoint(
    [](const Event* e) { 
        return e->getTime() > 10000 && e->type == CACHE_MISS;
    }
);
```

**单步执行和时间旅行**：

对于调试，单步执行（step）是基本功能。对于事件驱动模拟，可以实现：

- **事件级单步**：执行下一个事件
- **周期级单步**：执行到下一个时刻的所有事件

更高级的调试支持包括**时间旅行**——能够回到过去的时刻查看当时的系统状态。这需要保存中间的系统快照，成本较高。

## 1.4.5 性能监测的开销分析

收集性能数据本身有成本。理解这个成本对于设计有效的监测策略很重要。

**监测的直接成本**：

每条轨迹记录可能需要：

- 1-2次内存访问（写入缓冲区）
- 几个整数操作（格式化数据）
- 可能的系统调用（刷新到磁盘）

对于轨迹记录频繁发生（如每个事件都记录），这可能增加显著的开销。

**监测的缓存成本**：

性能数据的写入可能污染缓存，导致应用代码的缓存命中率下降。这个二阶效应可能比直接成本更显著。

**采样与统计学权衡**：

为了降低开销，通常采用采样：

```cpp
SAMPLE_RATE = 1000;  // 每1000个事件采样一次
if (event_count % SAMPLE_RATE == 0) {
    tracer.record(...);
}
```

这将监测开销降至大约0.1%。但需要足够的样本才能进行统计推论。根据中心极限定理，通常需要至少30-100个样本才能获得可靠的统计。

## 小结

性能监测是现代模拟器的必要组成部分，但需要在监测的详细程度和性能开销间进行权衡。事件驱动框架提供了自然的监测点——事件执行。通过分层监测和采样，可以以最小的开销获得关键的性能数据。

轨迹捕捉和回放对于调试非常有价值，但由于数据量大，需要仔细设计以避免过度的I/O开销。

---

---

**下一节**：[1.6 案例分析](./1.6-案例分析.md)