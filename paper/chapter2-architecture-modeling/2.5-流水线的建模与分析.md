# 2.5 流水线的建模与分析

## 概述

流水线是现代处理器的核心设计，通过将计算分解为多个阶段，实现高吞吐量。本节从流水线的结构、执行模型、以及性能特征等方面深入讨论流水线的建模。

## 2.5.1 流水线的本质与优势

### 流水线的基本概念

**流水线是将一个复杂的计算分解为多个简单的阶段，各阶段并行处理不同的数据包，从而提高吞吐量**。

```
非流水线执行：
Instr1: ├─ Fetch ─┤ Decode ─┤ Execute ─┤ Memory ─┤ Writeback ─┤
                                                              t=5
                                                              
Instr2: (等待) ┌─ Fetch ─┤ Decode ─┤ Execute ─┤ Memory ─┤ Writeback ─┤
                                                                        t=10

流水线执行（5级，理想情况）：
Instr1: ├─ Fetch ─┤ Decode ─┤ Execute ─┤ Memory ─┤ Writeback ─┤
Instr2:          ├─ Fetch ─┤ Decode ─┤ Execute ─┤ Memory ─┤ Writeback ─┤
Instr3:                   ├─ Fetch ─┤ Decode ─┤ Execute ─┤ Memory ─┤ Writeback ─┤
...
                                                              (吞吐量：1指令/周期)
```

### 流水线的性能特征

流水线的关键性能指标是**吞吐量**和**延迟**：

- **吞吐量**：单位时间内完成的指令数。理想的N级流水线吞吐量为1指令/周期。
- **延迟**：从指令进入到指令完成所需的时间。一般为流水线级数乘以每级的周期数。

流水线的优势来自于**并行性**：一旦Pipeline充满（所有Level都有数据），每周期可以完成一条指令。但代价是引入了**冒险**（Hazard）：指令间的依赖可能导致停顿。

## 2.5.2 流水线建模的核心机制

### Pipeline Component的结构

Pipeline在框架中是一个特殊的Component，内部包含：

```
Pipeline
├─ Stage缓冲数组 (stage_buffers_)
│  ├─ buffer[0]: 第一级的数据
│  ├─ buffer[1]: 第二级的数据
│  └─ ...
├─ 阶段处理函数数组 (stage_functions_)
│  ├─ process_func[0]: 第一级的处理逻辑
│  ├─ process_func[1]: 第二级的处理逻辑
│  └─ ...
├─ 停止谓词数组 (stall_predicates_)
│  ├─ can_stall[0]: 第一级的停止条件
│  ├─ can_stall[1]: 第二级的停止条件
│  └─ ...
└─ 延迟数组 (stage_latencies_)
   ├─ latency[0]
   ├─ latency[1]
   └─ ...
```

每个Stage缓冲是一个deque，允许同一阶段处理多个数据包（取决于buffer_size参数）。

### Pipeline的执行模型

Pipeline的tick()方法实现了数据流动的核心逻辑：

```
tick():
  循环处理每个Stage（从后向前）：
    Step 1: 检查该Stage的停止谓词
            如果返回true，停止此Stage的处理
    Step 2: 取出此Stage缓冲中的所有数据
    Step 3: 应用此Stage的处理函数
    Step 4: 将处理结果推送到下一Stage的缓冲
            或写入输出Port（如果是最后一级）
  
  调度下一个时钟周期的tick事件
```

**从后向前处理**的原因是避免在同一时刻处理"刚进入的数据"和"已处理的数据"。这确保了数据严格按照流水线方向流动，不会产生时序错误。

## 2.5.3 冒险与停止

### 冒险的本质

冒险是指指令间的依赖导致后续指令无法立即执行的情况。根据依赖类型，冒险分为三类：

1. **RAW（Read After Write）冒险**：后续指令需要前面指令的结果
2. **WAW（Write After Write）冒险**：两条指令都要写同一目标
3. **结构冒险**：指令竞争某个硬件资源

### 停止条件的表达

停止条件通过**停止谓词**（Stall Predicate）表达。谓词是一个函数，接收当前Stage的数据包，返回boolean：

```cpp
// 例1: 缓冲满导致停止
auto stall_if_next_full = [&](auto packet) {
    return stage_buffers_[current+1].size() >= max_buffer_size;
};

// 例2: RAW冒险检测
auto stall_if_raw_hazard = [&](auto packet) {
    auto instr = extract_instr(packet);
    return scoreboard_.has_pending_write(instr->rs1) ||
           scoreboard_.has_pending_write(instr->rs2);
};

// 例3: 资源冒险
auto stall_if_resource_busy = [&](auto packet) {
    return execution_engine_.is_busy();
};
```

### 停止的级联效应

当某个Stage停止时，前面的Stage自动停止（因为其数据无法推向停止的Stage），形成**背压**（Backpressure）。这种级联停止自动处理了冒险，无需显式的流控代码。

## 2.5.4 流水线深度与缓冲管理

### 流水线深度的影响

流水线深度（Level数量）影响性能和功耗：

- **浅流水线**（如5级）：延迟小，功耗低，但吞吐量受限
- **深流水线**（如15+级）：高吞吐量，但延迟大，容易产生branch misprediction

### 缓冲大小的配置

每个Stage可以有不同的缓冲大小：

```
Stage 0 (Fetch):    buffer_size = 1   (简单，无缓冲)
Stage 1 (Decode):   buffer_size = 2   (小缓冲，应对burst)
Stage 2 (Execute):  buffer_size = 4   (较大，应对可变延迟)
Stage 3 (Memory):   buffer_size = 8   (大缓冲，应对Miss)
Stage 4 (Writeback): buffer_size = 1
```

缓冲大小的选择权衡：
- 大缓冲：能吸收更多突发，但增加复杂性和功耗
- 小缓冲：简单、低功耗，但容易流控

## 2.5.5 流水线的性能分析

### 关键指标

```
吞吐量 (Throughput) = 完成指令数 / 总周期数
延迟 (Latency) = 指令进入到完成的周期数
停顿率 (Stall Rate) = 停止周期数 / 总周期数
```

### 性能模型

流水线的性能可以用经典的CPUTime模型：

```
CPUTime = 指令数 × (CPI × 周期时间)

其中：
CPI (Cycles Per Instruction) = 理想CPI + 停止导致的额外周期
理想CPI ≈ 1（理想流水线）
额外周期 = Σ(停止次数 × 停止周期数)
```

### 停止的来源分类

- **数据冒险引起的停止**：RAW等依赖
- **流控停止**：缓冲满导致
- **资源冒险停止**：竞争有限资源
- **分支预测错误**：需要flush流水线

每种停止的频率和周期数不同，影响整体性能。

## 2.5.6 实际应用：RISC-V 5级流水线

在建模Coral NPU的标量核时，使用5级流水线：

```
├─ Stage 0 (Fetch): 从指令内存读取
├─ Stage 1 (Decode): 指令解析、寄存器读
├─ Stage 2 (Execute): ALU操作、地址计算
├─ Stage 3 (Memory): 访存操作
└─ Stage 4 (Writeback): 结果写回

停止条件：
- Stage 1: 指令译码错误、跳转预测错误
- Stage 2: RAW冒险（等待前面指令的结果）
- Stage 3: Cache Miss（访存延迟）
- Stage 4: RegisterFile写端口冲突
```

## 小结

流水线建模的关键是理解**并行性与依赖的权衡**。框架通过Stage缓冲、停止谓词、以及背压机制，提供了表达复杂流水线行为的能力。精确的流水线建模是准确预测处理器性能的基础。