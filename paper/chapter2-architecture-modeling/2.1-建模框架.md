# 2.1 建模框架

## 概述

体系结构模拟是现代处理器设计的关键工具，用于在物理实现前探索设计空间、评估性能、进行功能验证。本章介绍的建模框架致力于解决一个根本问题：**如何以统一、灵活且高效的方式表达处理器的各个功能模块及其相互交互**。

传统的硬件建模方法通常采用HDL（硬件描述语言）或RTL级模拟，但这些方法存在明显的局限性。首先，RTL仿真速度慢，通常每秒只能模拟数百万条指令，对于大规模系统探索不可行。其次，RTL设计细节过多，开发周期长，难以快速迭代。再次，RTL级建模难以表达高层的架构特性和设计决策，导致模型与设计意图脱节。

本框架采用不同的设计哲学：**以架构级建模为主，通过事件驱动的执行模型，在保证足够精度的前提下，实现高速仿真和灵活的设计表达**。具体而言，框架以五个核心概念为基石（Port、Component、Connection、Pipeline、Stage），提供了从通信接口、组件封装、到流水线组织的完整建模能力。

## 2.1.1 框架设计的基本原则

在介绍具体设计前，需要阐明指导框架设计的几个基本原则：

**原则一：分离关注点（Separation of Concerns）**。框架将模拟系统的不同方面分离为独立的抽象：
- **通信**由Port和Connection处理，与计算逻辑无关
- **计算**由Component内部的业务逻辑处理，与通信方式无关  
- **时间管理**由事件驱动框架处理，与具体功能单元无关
- **流水线结构**由Pipeline和Stage处理，与各级的具体功能无关

这种分离使得开发者在实现某个功能模块时，可以专注于该模块的核心逻辑，而不被其他方面的复杂性分散注意力。

**原则二：可组合性（Composability）**。框架的各个元素（Port、Component、Connection等）都是可组合的，更复杂的系统通过组合简单元素而构建。例如，多个ALU可以组合成执行引擎，多个Stage可以组合成Pipeline。这种组合方式使得框架具有良好的可扩展性和模块化。

**原则三：可扩展性（Extensibility）**。框架提供了清晰的扩展机制，使得开发者可以：
- 定义新的Connection类型（如专用的握手协议）
- 继承Component和Stage创建特殊的硬件单元
- 定义新的DataPacket类型来传递专用数据
- 添加新的统计和追踪功能

**原则四：事件驱动执行（Event-Driven Execution）**。与传统的周期驱动仿真不同，框架采用事件驱动模型。这意味着只有当有事件发生时才进行计算，空闲的计算被跳过，从而大幅提升仿真速度。同时，事件驱动模型自然支持异步操作和可变延迟。

## 2.1.2 框架的分层架构

框架采用严格的分层设计，从下向上依次为：

1. **事件驱动层**（来自第一章）：提供时间管理和事件调度的基础设施，包括EventScheduler和事件队列。
2. **通信层**：Port和Connection这两个原语构成了所有模块间通信的基础，不论通信方向、延迟还是流控机制。
3. **组件层**：Component作为基础单元，代表任何具有输入端口、处理逻辑和输出端口的硬件模块。TickingComponent是Component的专化，用于周期驱动的模块。
4. **流水线层**：Pipeline和Stage支持对处理器流水线的建模。Pipeline本质上是一个特殊的Component，内部由多个Stage组成，每个Stage代表流水线的一级。
5. **应用层**：在上述抽象基础之上，开发者构建具体的处理器模型，如标量核心、向量执行引擎等。

这种分层架构的优势在于：不同层次之间的独立性，使得下层的改进不会影响上层的实现；同时，上层可以根据需要灵活地使用下层提供的抽象。

## 2.1.3 核心概念介绍

### Port：通信接口的抽象

**Port的本质**是Component之间通信的接入点。每个Port有明确的方向（输入或输出），以及一个关联的Connection。

在设计中，Port承载着两个重要功能：
- **数据传递**：Port存储临时数据，等待Connection在合适的时刻将数据转移给下一个Component
- **协议实现**：不同的Connection类型在Port的基础上实现不同的通信协议（握手、流控等）

Port的设计采用**最小化哲学**：Port本身不实现任何通信协议或流控逻辑，这些由Connection负责。这种设计使得Port可以适配多种通信方式。

### Component：计算单元的抽象

**Component是框架的核心抽象**，代表任何具有以下特征的硬件单元：
- 拥有一组输入/输出端口
- 实现某种计算或存储功能  
- 具有可预测的生命周期（初始化、运行、重置）
- 可以与其他Component组合

Component的设计强调**职责单一性**：一个Component应该代表一个清晰定义的硬件功能，如ALU、寄存器堆、或指令译码器。这样的设计使得：
- 每个Component易于理解和维护
- 模块间的依赖关系清晰
- 可以独立测试每个Component

**TickingComponent**是Component的一个重要专化，用于表达"周期驱动"的模块。它通过事件驱动框架实现每个时钟周期自动调用一次处理函数，从而模拟同步硬件的行为。

### Connection：通信协议的原语

**Connection负责Port之间的数据转移**，同时实现所需的通信协议。框架支持多种Connection原语：

- **Wire**：零延迟、无流控的直接连接，用于组合逻辑或同周期操作
- **DelayedWire**：带固定延迟的连接，用于模拟管道延迟或Cache访问
- **ReadyValidConnection**：实现握手协议，源端口的valid信号和目的端口的ready信号控制数据转移
- **CreditConnection**：基于信用令牌的流控，常用于网络互连

Connection的设计原则是**协议多态性**：开发者可以根据实际硬件特性选择或定义适合的Connection类型，而无需修改Component的实现。

### Pipeline与Stage：流水线的建模

**Pipeline是一个特殊的Component，代表多级流水线结构**。它通过以下机制管理数据流：
- **Stage缓冲**：每个Stage拥有一个缓冲区，存储在该阶段处理的数据
- **停止条件**：通过谓词函数，Pipeline可以检测到冒险、资源冲突等情况，适时停止某个阶段
- **背压机制**：当下游阶段缓冲满时，上游自动停止，实现流控

**Stage代表流水线的一级，实现特定的处理功能**。良好的Stage设计应该：
- 明确定义输入和输出的数据格式
- 实现停止条件的检测
- 提供完整的重置机制

Pipeline和Stage的分离使得开发者可以：
- 独立设计和测试每个流水线级
- 灵活调整Pipeline的深度（阶段数量）
- 轻松修改某个阶段的行为而不影响其他阶段

## 2.1.4 框架的执行模型

框架的执行模型建立在事件驱动的基础之上。整个仿真过程可以描述为：

```
初始化阶段:
  1. 创建所有Component和Connection
  2. 设置Component的初始状态
  3. 为所有TickingComponent调度首个时钟事件
  4. 向EventScheduler注册所有待处理事件

运行阶段（循环）:
  1. EventScheduler选择时间戳最小的事件
  2. 执行该事件的处理函数
  3. 处理函数可能调度新的事件（如下一个时钟周期）
  4. 返回至步骤1，直到事件队列为空或仿真结束条件满足

重置和清理:
  1. 调用所有Component的reset()方法
  2. 释放所有动态分配的资源
```

这个执行模型的关键特点是**事件驱动调度**：与传统的周期驱动仿真不同，事件驱动框架不会在每个周期都执行所有Component。相反，只有当Component有事件待处理时才会被调用。这带来的好处是：
- 仿真速度更快，特别是对于低活跃度的系统
- 自然支持可变延迟和异步操作
- 便于模拟I/O操作、中断等事件

## 2.1.5 设计权衡与考量

在设计框架时，需要在精度与速度之间做出权衡。

**精度方面**，框架支持多个精度等级：
- 功能级（Functional）：仅验证指令的行为是否正确，忽略微体系结构细节，仿真速度最快
- 架构级（Architectural）：模拟流水线、缓冲、冒险等基本的微体系结构特性，速度和精度的良好平衡
- 部分时序级（Partial Timing）：模拟一些关键的时序特性如不同功能单元的延迟差异

**速度方面**，框架通过多种优化实现高速仿真：
- 事件驱动调度避免空转
- 选择性地记录统计信息而非全面追踪
- 对热路径的代码进行优化（如Port的read/write操作）
- 支持批量仿真（运行多个工作负载并汇总统计）

在实际应用中，开发者应该根据具体的目标（如早期设计空间探索还是详细的性能预测）选择合适的精度等级。

## 小结

本节介绍了体系结构建模框架的核心设计理念和组成部分。框架以五个基本抽象（Port、Component、Connection、Pipeline、Stage）为基础，通过清晰的分层架构和事件驱动执行模型，提供了表达处理器设计的强大而灵活的方式。这套设计强调了分离关注点、可组合性和可扩展性，使得开发者可以聚焦于硬件功能本身，而将通信、时间管理等方面交由框架处理。
│  └─ Stage[N]: 处理函数
└─ 实现tick()方法 (通过TickingComponent)
```

**C++表示**:

```cpp
class Pipeline : public TickingComponent {
private:
    std::vector<PipelineStageData> stages_;  // 存储Stage的数据
    std::vector<StageFunction> stage_functions_;  // 处理函数
    
public:
    void setStageFunction(size_t stage_index, StageFunction func);
    void tick() override;  // 驱动流水线推进
};
```

### 数据流通过Port传递

```
Component    Port       Connection      Port    Component
┌─────────┐  ┌──────┐   ┌────────┐    ┌──────┐ ┌─────────┐
│ Process │  │write │──→│ buffer │───→│ read │ │ Process │
│    1    │  └──────┘   └────────┘    └──────┘ │    2    │
└─────────┘                                     └─────────┘
```

## 2.1.3 框架的设计原则

### 1. 关注点分离 (Separation of Concerns)

```cpp
// ❌ 混淆的设计
class ALU {
    void compute() {
        // 1. 计算逻辑
        // 2. 通信管理
        // 3. 时间控制
        // ... 混在一起
    }
};

// ✓ 正确的设计
class ALU : public TickingComponent {
    // 只关注计算逻辑
    void tick() override {
        // 执行计算
        // 通信通过Port/Connection自动处理
        // 时间通过EventScheduler管理
    }
};
```

### 2. 可组合性 (Composability)

通过Port和Connection的标准接口，不同的Component可以灵活组合：

```cpp
// Component可以像积木一样拼接
auto alu = std::make_shared<ALU>("alu", scheduler);
auto regfile = std::make_shared<RegFile>("regfile", scheduler);
auto lsu = std::make_shared<LSU>("lsu", scheduler);

// 通过Connection组合成系统
connectPorts(alu->output, regfile->input);
connectPorts(regfile->output, lsu->input);
connectPorts(lsu->output, alu->input);
```

### 3. 可扩展性 (Extensibility)

框架支持两种扩展方式：

**方式1: 继承Component创建新功能单元**

```cpp
class MyNewUnit : public Component {
    // 实现特定功能
};
```

**方式2: 继承Connection创建新通信协议**

```cpp
class MyProtocol : public Connection {
    // 实现新的通信协议
};
```

### 4. 可复用性 (Reusability)

Component设计为高度参数化，支持配置复用：

```cpp
// 参数化的寄存器文件配置
struct RegisterFileParameters {
    uint32_t num_registers;
    uint32_t num_read_ports;
    uint32_t num_write_ports;
};

// 用同一个RegFile类支持不同配置
auto regfile1 = std::make_shared<RegFile>(
    "rf1", scheduler,
    RegisterFileParameters(32, 8, 4)  // 标量核心配置
);

auto regfile2 = std::make_shared<RegFile>(
    "rf2", scheduler,
    RegisterFileParameters(128, 16, 8)  // 向量核心配置
);
```

## 2.1.4 Component的生命周期

每个Component都有明确的生命周期：

```
┌──────────────────────────────────────┐
│  1. 构造 (Construction)              │
│  │  - 创建Port                       │
│  │  - 初始化参数                     │
│  └─→ 2. 初始化 (Initialization)      │
│     │  - initialize() 被调用         │
│     │  - Port相互连接                │
│     │  - Connection启动              │
│     └─→ 3. 运行 (Execution)          │
│        │  - tick() 被周期调用(可选) │
│        │  - 接收来自Port的数据      │
│        │  - 发送到Port的数据        │
│        └─→ 4. 重置/清理             │
│           - reset() 被调用          │
│           - Port数据清除            │
│           - 状态复位               │
└──────────────────────────────────────┘
```

**C++实现**:

```cpp
class Component {
public:
    // 生命周期方法
    virtual void initialize() {}    // 初始化
    virtual void reset() {}         // 重置
    
    // Port管理
    void addPort(const std::string& name, PortDirection direction);
    std::shared_ptr<Port> getPort(const std::string& name);
};

// 使用示例
auto comp = std::make_shared<MyComponent>("comp", scheduler);

// Phase 1: Construction (done in constructor)
// Phase 2: Initialization
comp->initialize();

// Phase 3: Execution (automatic via EventScheduler)
scheduler.run();

// Phase 4: Cleanup
comp->reset();
```

## 2.1.5 事件驱动与周期驱动的结合

框架支持两种驱动方式的结合：

### 周期驱动模式

某些Component (如ALU、RegFile) 按固定周期运行：

```cpp
class ALU : public TickingComponent {
public:
    ALU(const std::string& name, EventScheduler& scheduler)
        : TickingComponent(name, scheduler, 1)  // 每周期一次
    {}
    
    void tick() override {
        // 执行ALU操作
    }
};
```

在这种模式下，EventScheduler自动为每个TickingComponent生成周期性事件。

### 事件驱动模式

某些Component (如中断控制器) 按需运行：

```cpp
class InterruptController : public Component {
public:
    void triggerInterrupt(uint64_t time) {
        scheduler_.schedule(std::make_shared<LambdaEvent>(
            time,
            [this](EventScheduler& s) {
                handleInterrupt();
            }
        ));
    }
};
```

### 混合模式

两者可以无缝结合：

```
┌────────────────────────────────────────┐
│  EventScheduler                        │
│  ├─ TickingComponent事件 (周期)        │
│  │  ├─ ALU tick @ T=0,1,2,...         │
│  │  ├─ RegFile tick @ T=0,1,2,...     │
│  │  └─ Pipeline tick @ T=0,1,2,...    │
│  │                                     │
│  └─ 用户定义事件 (按需)               │
│     ├─ 中断 @ T=1000                  │
│     ├─ I/O完成 @ T=2500               │
│     └─ 定时器 @ T=每5000             │
└────────────────────────────────────────┘
```

## 2.1.6 数据流的几种模式

### 模式1: 组合逻辑 (Combinational)

输入→计算→输出，在同一周期内完成：

```cpp
class Adder : public TickingComponent {
    void tick() override {
        auto a = readInput("a");
        auto b = readInput("b");
        int sum = a + b;
        writeOutput("sum", sum);
    }
};

// 时序：
// T=0: 读入 a=5, b=3
// T=0: 计算 sum=8
// T=0: 写出 sum=8
```

### 模式2: 时序逻辑 (Sequential)

输入→缓存→计算→输出，跨越多个周期：

```cpp
class DelayedAdder : public TickingComponent {
    std::queue<std::pair<int,int>> buffer_;
    
    void tick() override {
        if (!buffer_.empty()) {
            auto [a, b] = buffer_.front();
            buffer_.pop();
            writeOutput("sum", a + b);
        }
        
        auto input = readInput("input");
        if (input) {
            buffer_.push(input);
        }
    }
};

// 时序：
// T=0: 输入a=5,b=3到buffer
// T=1: 计算并输出sum=8
```

### 模式3: 流水线 (Pipeline)

多级处理，每级一个周期：

```cpp
class PipelinedAdder : public Pipeline {
    PipelinedAdder(EventScheduler& scheduler)
        : Pipeline("adder", scheduler, 1, 3) {
        
        // Stage 0: 读操作数
        setStageFunction(0, [](auto data) { return data; });
        
        // Stage 1: 相加
        setStageFunction(1, [](auto data) {
            auto result = std::make_shared<IntDataPacket>();
            result->value = data->a + data->b;
            return result;
        });
        
        // Stage 2: 写结果
        setStageFunction(2, [](auto data) { return data; });
    }
};

// 时序：
// T=0: 数据在Stage 0
// T=1: 数据在Stage 1，执行相加
// T=2: 数据在Stage 2，输出结果
// T=3: 新数据进入Stage 0
```

## 2.1.7 框架的使用流程

### 第一步: 定义自己的Component

```cpp
class MyComponent : public Component {
public:
    MyComponent(const std::string& name, EventScheduler& scheduler)
        : Component(name, scheduler) {
        addPort("input", PortDirection::INPUT);
        addPort("output", PortDirection::OUTPUT);
    }
    
    void initialize() override {
        // 初始化逻辑
    }
};
```

### 第二步: 创建并连接Component

```cpp
EventScheduler scheduler;

auto comp1 = std::make_shared<ALU>("alu", scheduler);
auto comp2 = std::make_shared<RegFile>("regfile", scheduler);

auto conn = std::make_shared<Connection>("link", scheduler);
conn->addSourcePort(comp1->getPort("output"));
conn->addDestinationPort(comp2->getPort("input"));
```

### 第三步: 初始化并运行

```cpp
comp1->initialize();
comp2->initialize();

scheduler.run();  // 或指定最大时间: scheduler.run(10000);
```

## 2.1.8 框架相对于循环驱动的优势

### 表1: 框架特性对比

| 特性 | 事件驱动框架 | 循环驱动 |
|------|-----------|---------|
| 跳过空闲周期 | ✓ 自动 | ✗ 需手工 |
| 多时钟域支持 | ✓ 原生 | ✗ 复杂 |
| 异步事件 | ✓ 优雅 | ✗ 低效 |
| 代码可复用性 | ✓ 高 | ✗ 低 |
| 学习曲线 | ✗ 陡 | ✓ 平缓 |
| 调试难度 | ✗ 中等 | ✓ 简单 |

## 小结

本节介绍了体系结构建模框架的整体设计：

1. **分层架构**: 从Component层到Connection层到DataPacket层
2. **核心概念**: Component, Port, Connection, Pipeline, Stage
3. **设计原则**: 关注点分离、可组合性、可扩展性、可复用性
4. **生命周期**: 构造→初始化→运行→重置
5. **两种驱动方式**: 周期驱动和事件驱动的结合

---

**下一小节**: [2.2 Port设计](./2.2-Port设计.md)
