# 2.6 阶段设计的原则与实现

## 概述

Stage是Pipeline的基本单位，代表流水线的一级。良好的Stage设计是实现高精度流水线建模的关键。本节从设计原则、标准阶段的实现、以及高级特性等方面深入讨论。

## 2.6.1 Stage的抽象与职责

### Stage的定义

**Stage代表流水线中的一个处理级，负责对数据包执行特定的变换**。从数据流角度，Stage实现一个映射：

```
Input DataPacket → Process → Output DataPacket
```

更准确地说，Stage可以实现以下行为：

1. **数据转换**：根据输入生成输出（如指令Decode）
2. **状态更新**：修改Component的内部状态（如PC更新）
3. **副作用**：与其他Component交互（如寄存器读写）
4. **停止判决**：决定是否应该停止流水线（冒险检测）

### Stage的核心接口

一个Stage应该实现以下接口：

```
process(input): 执行该级的处理
  输入: 来自前一级的DataPacket
  输出: 处理后的DataPacket或nullptr（停止）
  
shouldStall(): 该Stage是否应该停止
  返回: true表示应该停止，false表示可以继续
  
getLatency(): 该Stage的延迟
  返回: 该操作需要多少个时钟周期
  
reset(): 重置Stage的状态
```

## 2.6.2 标准阶段的实现

### Fetch阶段

Fetch阶段从指令内存读取指令：

**职责**：
- 根据程序计数器（PC）从指令内存读取指令
- 更新PC指向下一条指令（顺序执行）或跳转目标（分支）
- 处理I-Cache的Hit/Miss

**设计考量**：
- Fetch通常不会停止（除非遭遇I-Cache Miss或分支预测错误）
- 需要与分支预测单元协作处理跳转
- 如果发生分支预测错误，需要flush后续已发射的指令

**性能特性**：
- I-Cache命中时延迟为1周期
- I-Cache未命中时延迟可能为10-20个周期

### Decode阶段

Decode阶段对指令进行解析：

**职责**：
- 从指令字段提取操作码、源操作数、目标寄存器等
- 决定指令的类型和操作
- 可能从RegisterFile预读操作数

**设计考量**：
- Decode的延迟通常为1周期，但如果涉及复杂指令可能更长
- 需要与RegisterFile协作进行操作数读取
- 可能需要检测操作数的冒险（RAW）

**在Coral NPU中**：
- 需要同时处理标量指令和向量指令
- 向量指令的Decode可能更复杂（需要提取向量长度等参数）

### Execute阶段

Execute阶段执行计算操作：

**职责**：
- 执行ALU操作、逻辑运算、乘法等
- 计算访存地址
- 处理立即数的扩展和编码

**设计考量**：
- 不同操作的延迟不同（ADD为1周期，MUL为3-4周期）
- 需要检测结构冒险（硬件资源冲突）
- 可能发生异常（非法操作、溢出等）

**在Coral NPU中**：
- 包含多个ALU（并行处理）
- 支持多种扩展（RV32M乘法、ZBB位操作等）
- 与向量执行引擎共享资源

### Memory阶段

Memory阶段处理访存操作：

**职责**：
- 执行Load和Store操作
- 与Data Cache交互
- 处理访存异常

**设计考量**：
- Load操作延迟可变（L1 Hit为3-4周期，Miss为10-100周期）
- Store通常可以更快完成（buffered）
- 需要处理内存顺序（Store Forwarding）

**在Coral NPU中**：
- LSU支持多端口并发访存
- 需要与Cache系统交互
- 可能有多个未完成的访存请求

### Writeback阶段

Writeback阶段将结果写回RegisterFile：

**职责**：
- 将计算结果写入目标寄存器
- 更新RegFile的记分板
- 可能触发依赖指令的唤醒

**设计考量**：
- Writeback通常为1周期
- 可能需要处理多个执行单元的并发写入（仲裁）
- RegisterFile的写端口数量是系统的关键资源

## 2.6.3 Stage的停止与冒险检测

### 冒险检测的机制

Stage通过shouldStall()方法实现冒险检测。冒险检测需要访问系统的全局状态（如RegisterFile的记分板）来判断依赖是否存在。

### RAW冒险检测

```
当前指令: add x4, x1, x2
前面指令: mul x1, x3, x4  (尚未完成)

冒险: x1是mul的目标，也是add的源
处理: Decode阶段检测到x1未就绪，停止add
```

### WAW冒险检测（乱序执行系统）

```
指令1: add x5, x1, x2
指令2: add x5, x3, x4    (乱序执行，可能先完成)

冒险: 都要写x5，导致结果顺序错误
处理: 使用Reorder Buffer确保正确顺序
```

## 2.6.4 向量处理的Stage设计

### RVV向量指令的处理特点

向量指令与标量指令的流水线处理存在本质区别：

1. **数据宽度**：一条向量指令处理多个数据元素
2. **执行时间**：向量操作可能需要多个周期才能完成所有Lane
3. **资源争用**：向量单元与标量单元可能共享总线或存储

### RVV Dispatch阶段

**职责**：
- 将向量指令dispatch到向量执行引擎
- 进行向量冒险检测
- 确定VLEN、SEW等向量参数

**设计特点**：
- 比标量Dispatch更复杂，需要检查向量寄存器的忙标记
- 需要管理向量指令的生命周期（可能跨多个周期）

### RVV执行与数据并行化

向量执行通常有两种方式：

1. **Lane并行**：将向量分解为多个Lane，由多个执行单元并行处理
2. **时间并行**：用单个执行单元经过多个周期处理整个向量

```
例：64-bit向量，SEW=32，4个Lane

向量操作: v1 = v2 + v3

Lane并行（4个加法器）：
Cycle 0: lane0, lane1, lane2, lane3 同时执行
结果: 所有元素在Cycle 1就绪

时间并行（1个加法器）：
Cycle 0: lane0 执行
Cycle 1: lane1 执行
Cycle 2: lane2 执行
Cycle 3: lane3 执行
结果: 所有元素在Cycle 4就绪
```

## 2.6.5 Stage的状态与可重入性

### Stage的状态管理

Stage可能包含内部状态：
- **临时状态**：当前处理的数据包相关的临时变量
- **持久状态**：跨多个周期维护的状态（如迭代计数器、向量处理进度）

### 可重入性的考量

某些Stage的操作可能不是原子的，需要多个周期才能完成。例如，向量操作可能需要4个周期处理4个Lane。此时，Stage需要管理其进度状态，确保不会被中断或重复执行。

## 小结

Stage的设计体现了流水线建模的细节和复杂性。从简单的单周期阶段到复杂的多周期或异步阶段，Stage提供了表达处理器各个功能单元行为的能力。理解Stage的设计原则对于构建精确的处理器模型至关重要。