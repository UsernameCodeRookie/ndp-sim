# 3.4 寄存器堆与冒险检测

## 概述

RegisterFile（寄存器堆）是处理器的关键资源，存储程序状态和中间计算结果。其设计直接影响处理器的吞吐量和性能。本节讨论寄存器堆的设计、冒险检测机制、以及与多执行单元的协作。

## 3.4.1 RegisterFile的结构与功能

### 基本结构

Coral NPU的标量RegisterFile包含：

```
32个通用寄存器 (x0-x31)
├─ x0: 硬连线为0（不可写）
├─ x1: 返回地址
├─ x2: 栈指针
├─ x5, x27-x31: 临时寄存器
├─ x3-x4, x8-x9: 保存寄存器
├─ x10-x17: 函数参数和返回值
└─ x18-x26: 临时寄存器

读端口数量：16
└─ 支持16个并发的读操作

写端口数量：8
└─ 支持8个并发的写操作

访问延迟：
├─ 读：0周期（组合逻辑）
└─ 写：在时钟边界生效
```

### 为什么需要多端口？

```
在支持多执行单元和高吞吐量的流水线中：
- 多个指令同时在Dispatch阶段读操作数
- 多个指令同时在Writeback阶段写结果

单端口设计的问题：
  只有第一条指令能成功读/写，其他指令必须停止

多端口设计的优势：
  所有指令可以并发读/写，提升吞吐量

权衡：
- 优点：高吞吐量
- 缺点：面积增加（与端口数平方成正比）
        功耗增加（更多的读写电路）
        布局布线复杂度增加
```

## 3.4.2 记分板（Scoreboard）

### 记分板的目的

记分板追踪每个寄存器的"忙"状态，用于冒险检测：

```
数据结构：
struct Scoreboard {
  bool busy[32];              // 寄存器是否忙
  int producer_instr[32];     // 哪条指令在写这个寄存器
  int producer_completion_time[32];  // 预期完成时间
};
```

### 记分板的工作流程

```
Dispatch阶段：
1. 检查源寄存器（rs1, rs2）的busy标记
2. 如果busy==true且producer未完成，停止dispatch
3. 如果可以dispatch，标记目标寄存器（rd）为busy
   busy[rd] = true
   producer_instr[rd] = current_instr_id

Writeback阶段：
1. 指令完成写入
2. 清除目标寄存器的busy标记
   busy[rd] = false
```

### 记分板与前向（Forwarding）

虽然记分板可以检测冒险，但通过前向（Forwarding）可以减少停顿：

```
Without Forwarding:
t=0: ALU指令发射，计算 x1 = x2 + x3
t=4: Writeback，x1不再忙

t=3: 下一条指令需要x1，但x1还在忙
     必须停止，等到t=4
     
     总停顿：1周期

With Forwarding:
t=0: ALU指令发射，计算 x1 = x2 + x3
t=3: 结果产生但还未写入RegisterFile
     直接将结果前向给下一条指令
     
     总停顿：0周期
```

### 前向的实现

```
前向数据路（Forwarding Path）：
1. 识别即将完成的指令的结果
2. 直接转发给下一条指令
3. 绕过RegisterFile

实现的复杂性：
- 多个执行单元可能同时产生结果
- 需要选择器选择最新的结果
- 影响关键路径（可能降低频率）
```

## 3.4.3 冒险检测的详细实现

### RAW冒险的检测与处理

```
当Dispatch一条指令时：
  instr_rs1 = 源寄存器1
  instr_rs2 = 源寄存器2
  
  if (busy[instr_rs1] || busy[instr_rs2]):
    // 至少一个源寄存器忙
    if (can_forward):
      // 检查是否可以前向
      if (producer_completion_time[rs] <= current_time + 1):
        // 可以前向，无需停止
        forward_result(rs)
      else:
        // 无法前向，必须停止
        stall()
    else:
      stall()
```

### WAW和WAR冒险

在顺序流水线中，WAW和WAR冒险通常不会发生，因为指令按顺序执行。但在考虑乱序完成时：

```
WAW冒险示例：
  add x1, x2, x3      (延迟1周期)
  mul x1, x4, x5      (延迟4周期)

如果mul比add先完成，将导致x1的值错误。

解决方案：
  使用时间戳机制：
  - 为每条指令分配发射顺序号
  - Writeback时，只写入具有最新顺序号的结果
  - 旧的结果被丢弃
```

## 3.4.4 寄存器窗口（Register Windowing）

某些RISC架构（如SPARC）使用寄存器窗口来加速函数调用。虽然RISC-V未采用此机制，但作为优化值得讨论：

```
寄存器窗口的思想：
- 保存不同函数调用的不同寄存器集合
- 避免保存/恢复寄存器的开销

缺点：
- 寄存器文件面积大幅增加
- 复杂性增加
- 不符合RISC-V的简洁设计哲学

结论：Coral NPU采用扁平的32寄存器设计
```

## 3.4.5 向量寄存器堆

Coral NPU还包含32个向量寄存器（v0-v31）用于RVV指令：

```
向量RegisterFile的特点：
- 每个向量寄存器的宽度可配置（VLEN）
  * 典型配置：256bit或512bit
  * 意味着可以同时操作8个或16个32-bit元素

多端口配置：
- 读端口：支持多个向量操作的并发读
- 写端口：支持多个向量结果的并发写

访问延迟：
- 向量读：可能需要多周期（取决于VLEN）
- 向量写：可能需要多周期
```

## 小结

RegisterFile和记分板是处理器冒险检测和控制流的核心。精心设计的多端口结构和前向机制可以显著减少停顿，提升吞吐量。但同时需要控制面积和功耗的增长，这涉及复杂的工程权衡。

---

**下一节**: [3.5 RVV向量执行引擎](./3.5-RVV向量执行引擎.md)