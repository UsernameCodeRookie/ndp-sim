# 3.3 功能单元的设计与优化

## 概述

Coral NPU包含多个专用功能单元（ALU、MLU、LSU等），每个单元实现特定的计算功能。本节详细讨论各功能单元的设计原则、实现方式、以及性能优化。

## 3.3.1 ALU（算术逻辑单元）

### 功能与操作

ALU是最基础的执行单元，支持RISC-V RV32I基础指令集的算术和逻辑操作：

```
支持的操作类别：
1. 算术操作：
   - ADD, ADDI: 加法
   - SUB: 减法
   - SLT, SLTI: 有符号比较
   - SLTU, SLTIU: 无符号比较

2. 逻辑操作：
   - AND, ANDI: 按位与
   - OR, ORI: 按位或
   - XOR, XORI: 按位异或

3. 移位操作：
   - SLL, SLLI: 逻辑左移
   - SRL, SRLI: 逻辑右移
   - SRA, SRAI: 算术右移

4. 比特操作扩展（ZBB）：
   - ANDN: 与非
   - ORN: 或非
   - XNOR: 异或非
   - POPCNT: 计数1的个数
   - CLZ, CTZ: 前导/尾部零计数
   
共计30+种操作
```

### ALU的性能特征

```
延迟：1周期
吞吐量：每周期1条指令
面积：相对较小
功耗：中等（取决于操作）
```

ALU的设计强调速度，所有操作都在单个周期内完成。这使得ALU成为流水线中的瓶颈较少的单元。

### ALU的实现细节

```
ALU的内部结构：
1. 操作码解码 (1级)
2. 操作数选择 (1级)
   - 立即数MUX选择
   - 寄存器数据转发
3. 计算电路 (1级)
   - 加法器
   - 逻辑单元
   - 移位器
4. 结果选择 (1级)
   - 根据操作码选择合适的结果

总延迟：通常1周期（经过优化）
```

### ALU的资源需求

在一个处理器核中，通常需要2个ALU以支持高吞吐量：

```
如果只有1个ALU，且大部分指令都是算术操作：
- 多条算术指令可能竞争同一ALU
- 导致资源冒险和停顿

配置2个ALU的益处：
- 大多数指令依赖可以通过交错发射解决
- 充分利用指令级并行性
```

## 3.3.2 MLU（乘法/除法单元）

### 功能与设计

MLU负责RISC-V RV32M扩展的乘法和除法操作。与ALU的单周期操作不同，MLU的操作需要多个周期。

```
支持的操作：
1. 乘法：
   - MUL: 低32位结果
   - MULH: 高32位结果（有符号×有符号）
   - MULHU: 高32位结果（无符号×无符号）
   - MULHSU: 高32位结果（有符号×无符号混合）
   延迟：3-4周期（取决于实现）

2. 除法：
   - DIV: 有符号除法
   - DIVU: 无符号除法
   - REM: 有符号余数
   - REMU: 无符号余数
   延迟：32-40周期（SRT算法或类似）
```

### 乘法单元的实现

现代处理器通常采用**Wallace Tree或Dadda Tree**实现快速乘法：

```
简化流程（32×32位乘法）：
1. 部分积生成 (1周期)
   - 32个部分积
   
2. 树形加法 (2周期)
   - Wallace/Dadda树并行求和
   
3. 最终加法 (1周期)
   - 加法器求最终结果

总延迟：3-4周期
```

### 除法单元的实现

除法比乘法更复杂，通常采用SRT（Signed Radix）算法：

```
SRT除法的工作流程（简化）：
1. 初始化：设置被除数、除数、余数
2. 迭代（32次迭代，每次产生1-2位商）：
   - 比较余数与除数
   - 决定商的下一位
   - 余数左移，减去/加上除数
3. 完成：输出商和余数

总延迟：30-40周期（取决于迭代次数）
```

### MLU的资源管理

由于MLU的延迟长，需要特殊的资源管理：

```
MLU的处理能力：
- 单个MLU可能每2-4周期完成一个乘法
- 允许多个乘法在MLU中重叠执行（乱序）

设计方案：
1. 流水线化MLU：
   - 内部多级流水线（如乘法4级）
   - 每周期可接受新的乘法指令
   缺点：面积大，功耗高

2. 迭代式MLU：
   - 单个MLU，内部迭代计算
   - 需要调度器跟踪未完成的操作
   优点：面积小，功耗低
   缺点：占用周期多

Coral NPU采用折衷方案：
- 乘法使用流水线化实现（4级）
- 除法使用迭代式实现
```

## 3.3.3 LSU（Load/Store单元）

### 功能与复杂性

LSU是处理器中最复杂的单元之一，负责所有的数据访存操作：

```
支持的操作：
1. Load操作：
   - LW: 读取32位字
   - LH, LHU: 读取16位半字
   - LB, LBU: 读取8位字节

2. Store操作：
   - SW: 写32位字
   - SH: 写16位半字
   - SB: 写8位字节

3. 内存顺序保证：
   - Store可能先完成，但结果对后续Load可见
   - 需要Store Forwarding机制
```

### Cache的影响

LSU的性能关键取决于Cache的命中率：

```
L1 Data Cache的典型配置：
- 容量：32KB-64KB
- 行大小：64字节
- 延迟（Hit）：3-4周期
- 延迟（Miss）：10-30周期（取决于L2）

性能影响的计算：
假设Load指令比例为25%，Hit率为90%

平均访存延迟 = 0.9 × 4 + 0.1 × 20 = 5.6周期

对CPI的影响（假设Load依赖链）：
如果每3条指令有1条Load，且Load延迟为4周期
→ CPI增加约1.4倍
```

### Store Forwarding机制

Store操作通常不会等待数据实际写入Memory，而是缓存在Store Buffer中。后续的Load可以从Store Buffer转发而不必等待Memory。

```
示例：
  Store x, 100   -> Store Buffer: (x, 100)
  Load r, x      -> 从Store Buffer转发，r=100
                    不需要等待内存访问完成

设计考量：
1. Store Buffer的大小：通常8-16项
2. 地址匹配逻辑：检查Load地址是否在Store Buffer中
3. 部分匹配处理：Load跨越多个Store的情况
```

### LSU的并发支持

现代处理器的LSU通常支持多个未完成的访存操作：

```
Load Queue (LQ): 存储未完成的Load指令
  - 项数：通常16-32
  - 用途：追踪Load的状态，等待Cache返回数据

Store Queue (SQ): 存储未完成的Store指令
  - 项数：通常8-16
  - 用途：缓存Store数据，等待写入Cache

Memory Order Buffer (MOB): 协调LQ和SQ
  - 检查数据依赖（Load是否依赖前面的Store）
  - 支持乱序执行
  - 内存顺序正确性的保证
```

## 3.3.4 功能单元的调度与仲裁

### Dispatch的仲裁策略

当多条指令同时可以dispatch时，Dispatch阶段需要决定哪些指令真正发射：

```
仲裁规则（优先级从高到低）：
1. 非访存指令（ALU、MLU操作）
   - 这些通常没有长延迟，优先发射
   
2. Load操作
   - 可能有Miss导致长延迟
   - 早发射Load可以隐藏延迟
   
3. Store操作
   - 通常不关键路径，可以稍后dispatch

示例的Dispatch逻辑：
for i = 0 to dispatch_width-1:
  candidates = ready_instructions[i:dispatch_width]
  
  // 按优先级排序
  sort(candidates, by_priority)
  
  // 尝试发射
  for each candidate:
    if has_execution_unit(candidate):
      dispatch(candidate)
      break
```

## 3.3.5 功能单元的功耗管理

### 动态频率与功耗调整（DVFS）

Coral NPU支持动态功耗管理：

```
在低负载时：
- 降低时钟频率
- 降低电压（与频率成比例）
- 功耗 ∝ V² × f，降幅显著

场景：
- 神经网络推理的某个阶段负载低
- 系统可以自动降频降压
- 节省功耗的同时保持足够性能
```

### 时钟门控（Clock Gating）

当某个功能单元不被使用时，可以关闭其时钟：

```
示例：当没有乘法指令待执行时
- MLU的内部时钟被关闭
- 节省MLU的动态功耗
- 无需改变外部接口

实现：
  if (mlu_has_pending_instructions == false):
    mlu_clock_enable = false
  else:
    mlu_clock_enable = true
```

## 小结

功能单元的设计体现了性能、面积和功耗的多维度权衡。ALU的高速设计使其成为处理器的基础，MLU的流水线设计支持指令级并行性，LSU的复杂设计处理内存系统的变数。每个单元的精心设计都对整体处理器性能有重要影响。

---

**下一节**: [3.4 寄存器堆与记分板](./3.4-寄存器堆与记分板.md)