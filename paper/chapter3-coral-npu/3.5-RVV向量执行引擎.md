# 3.5 RVV向量执行引擎

## 概述

RISC-V向量扩展（RVV）是Coral NPU的关键创新，使其能够进行高效的数据级并行计算。本节详细讨论RVV指令集、向量执行引擎的架构、以及标量与向量的协作机制。

## 3.5.1 RVV指令集的基本概念

### 向量长度（VLEN）与配置

RVV的核心概念是**向量长度**（VLEN），表示单个向量寄存器的位宽：

```
VLEN的典型值：
- 128位（1个128-bit寄存器）
- 256位（1个256-bit寄存器 = 8个32-bit元素）
- 512位（1个512-bit寄存器 = 16个32-bit元素）
- 1024位或更大

Coral NPU的配置：
- 可配置VLEN，默认256位
- 意味着可以同时处理8个32-bit的数据元素
  v0 = [e0, e1, e2, e3, e4, e5, e6, e7]
       ├─32bit──┼──32bit──┼...
```

### 向量类型与元素宽度（SEW）

向量操作可以在不同的元素宽度下进行：

```
SEW (Selected Element Width):
- SEW=8: 8-bit元素（1个256-bit向量=32个元素）
- SEW=16: 16-bit元素（1个256-bit向量=16个元素）
- SEW=32: 32-bit元素（1个256-bit向量=8个元素）
- SEW=64: 64-bit元素（1个256-bit向量=4个元素）

向量操作的灵活性：
  在同一向量寄存器中，可以选择不同粒度的操作
  这样利用了向量宽度而不需要转换数据格式
```

### 向量长度寄存器（VL）

VL指定了当前操作中实际使用的向量元素数量：

```
VL的作用：
- 通常VL <= VLEN / SEW
- 允许处理长度不是向量宽度倍数的数据

示例（VLEN=256, SEW=32）：
- VLEN/SEW = 8
- 如果要处理一个长度为7的向量：
  VL = 7，最后一个元素位置空
  向量操作只对前7个元素有效

这对于未对齐的数据处理至关重要
```

## 3.5.2 RVV指令的分类

### 向量算术指令

```
向量加法: vadd.vv v1, v2, v3
  v1[i] = v2[i] + v3[i] for i in 0..VL-1

向量乘法: vmul.vv v1, v2, v3
  v1[i] = v2[i] * v3[i]

向量标量混合: vadd.vs v1, v2, x3
  v1[i] = v2[i] + (x3 sign-extended)

其他操作：减法、逻辑运算、比较等
```

### 向量访存指令

```
向量加载: vle32.v v1, (x2)
  从地址x2加载8个32-bit元素到v1

向量存储: vse32.v v1, (x2)
  将v1的8个32-bit元素存储到地址x2

步长加载: vlse32.v v1, (x2), x3
  从地址x2开始，以步长x3加载
  v1[0] = mem[x2]
  v1[1] = mem[x2 + x3]
  v1[2] = mem[x2 + 2*x3]
  ...
  
用处：处理矩阵、稀疏数据等
```

### 向量减少操作

```
求和: vredsum.vs v1, v2, v3
  v1[0] = v3[0] + sum(v2[0:VL-1])

求最大值: vredmax.vs v1, v2, v3
  v1[0] = max(v2[0:VL-1]) concatenated with v3[0] upper bits

这些操作将向量化简为标量值，常用于最后的结果聚合
```

## 3.5.3 向量执行引擎的架构

### 三阶段流水线

RVV后端采用简化的3级流水线：

```
Stage 0 (Dispatch):
  ├─ 向量指令发射到向量执行
  ├─ 冒险检测（向量寄存器依赖）
  └─ 向量参数设置（VL, SEW等）

Stage 1 (Execute):
  ├─ 多个Lane并行执行
  ├─ 处理所有VL个元素
  └─ 可能跨多周期（取决于VLEN）

Stage 2 (Retire):
  ├─ 确保顺序完成
  ├─ 更新向量寄存器
  └─ 通知标量核完成
```

### Lane并行架构

```
VLEN=256时，VLANE=8个Lane（每Lane处理32-bit）

向量加法的执行：
  Lane0: v1[0] = v2[0] + v3[0]
  Lane1: v1[1] = v2[1] + v3[1]
  Lane2: v1[2] = v2[2] + v3[2]
  ...
  Lane7: v1[7] = v2[7] + v3[7]

吞吐量：
  单条向量指令在1-2周期内完成8个标量操作
  相当于8条标量指令在1-2周期内完成
  吞吐量 = 8 / 2 = 4指令等效/周期
```

### 向量加载存储单元（VLSU）

向量访存比标量访存更复杂：

```
挑战1：地址生成
  需要为每个Lane生成不同的地址
  - 连续访问：addr + lane_id * element_size
  - 步长访问：addr + lane_id * stride
  - 索引访问（向量索引）

挑战2：缓存行边界
  单个向量可能跨多个缓存行
  需要分割请求

挑战3：未对齐访问
  处理不对齐的访存

设计方案：
  使用多个访存请求，可以并发发送到Cache
```

## 3.5.4 标量与向量的协作

### 寄存器的独立性

```
标量和向量有独立的寄存器：
- 标量：x0-x31（32个32-bit）
- 向量：v0-v31（32个VLEN-bit）

数据转移：
- 向量结果无法直接用于标量操作（反之亦然）
- 需要显式的转换指令
  vmv.x.s x1, v2      // 从向量提取标量
  vmv.s.x v1, x2      // 从标量转为向量
```

### Dispatch的仲裁

当标量和向量指令同时可以发射时：

```
仲裁策略：
1. 如果向量指令可以dispatch，优先发射向量
   - 向量指令效率更高（同一周期处理多元素）
   
2. 如果没有向量指令或向量单元忙，dispatch标量

目的：
- 最大化向量利用率
- 充分发挥向量的高吞吐量
```

### 向量指令的依赖管理

向量指令之间可能存在类似于标量的依赖：

```
示例1：RAW依赖
  vadd.vv v1, v2, v3      // v1 = v2 + v3
  vmul.vv v4, v1, v5      // v4 = v1 * v5
  
  v4依赖v1，不能立即dispatch

示例2：向量-标量依赖
  vadd.vv v1, v2, x3      // v1[i] = v2[i] + x3
  
  x3必须在向量操作前就绪
  如果x3来自前面指令，可能需要等待

记分板机制：
  - 扩展记分板以跟踪向量寄存器
  - 检测向量间的依赖
  - 检测向量-标量的混合依赖
```

## 3.5.5 向量执行的延迟与吞吐量

### 各类向量操作的延迟

```
操作类型              延迟（周期）    说明
──────────────────────────────────────
向量加法              1-2           单Lane可在1周期完成
向量乘法              3-4           多Lane需要更多周期
向量访问（Hit）       4-6           需要多个地址生成
向量访问（Miss）      20+           Cache Miss导致长延迟
向量约化              3-4           需要多级树形约化

向量指令的吞吐量（相对于标量）：
  单条向量指令 ≈ VLEN/SEW条标量指令
  
  吞吐量提升 = (VLEN/SEW) / 延迟倍数
  
  例如（VLEN=256, SEW=32, Lane并行度8）：
  8条加法操作在2周期完成
  等效吞吐量 = 8/2 = 4标量指令/周期
```

### 性能预测

```
纯向量循环的性能：
  for (int i = 0; i < 1000; i++) {
    c[i] = a[i] + b[i];
  }
  
标量实现：
  1000条加法 × 1周期 = 1000周期
  
向量实现（VLEN=256, SEW=32）：
  1000 / 8 = 125条向量加法
  125条加法 × 2周期（含依赖延迟）= 250周期
  
性能提升：1000 / 250 = 4倍
```

## 3.5.6 向量与缓存的交互

### 向量访存对缓存的压力

向量加载会对Cache产生高频率的访问：

```
单个向量加载 = VLEN/SEW次的标量加载
缓存压力 ≈ VLEN/SEW倍

内存带宽需求：
  单条向量加法指令：2次加载 + 1次存储
  = 3 × VLEN/SEW次的数据转移
  
例如，1000条向量指令/秒需要的带宽：
  1000 × 3 × 8元素 × 4字节 = 96 MB/s
```

### Cache优化策略

```
1. 向量化预取：
   在进入向量循环前，预取所需的数据块

2. 步长识别：
   硬件识别步长访问模式，优化预取

3. 流缓冲：
   对于连续访问，使用流缓冲减少缓存污染

4. 时间局部性优化：
   充分利用L1缓存的同时，避免过度污染
```

## 小结

RVV向量执行引擎是Coral NPU的性能核心，通过SIMD并行处理实现显著的吞吐量提升。向量的设计强调了灵活性（可配置VLEN和SEW）和与标量指令的无缝集成。理解向量执行的细节对于优化神经网络推理等向量化应用至关重要。

---

**下一节**: [3.6 微体系结构的优化与扩展](./3.6-微体系结构的优化与扩展.md)