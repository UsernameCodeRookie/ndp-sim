# 3.2 标量核心的指令流水线

## 概述

标量核心是Coral NPU的传统指令执行引擎，采用5级流水线设计。本节详细讨论流水线的各个阶段、冒险处理、以及性能特性。

## 3.2.1 5级流水线的阶段设计

Coral NPU的标量核采用典型的RISC流水线设计：

```
┌─────────────────────────────────────────────────────┐
│  流水线阶段结构                                     │
└─────────────────────────────────────────────────────┘

Stage 0 (Fetch): 指令获取
  输入: PC (程序计数器)
  操作: 从I-Cache读取指令
  输出: (PC, 指令字)
  延迟: 1周期 (I-Cache Hit)
  
Stage 1 (Decode): 指令解码
  输入: (PC, 指令字)
  操作: 解析操作码、源操作数地址、目标寄存器
  输出: (PC, 操作码, rs1, rs2, rd, 立即数)
  延迟: 1周期
  
Stage 2 (Dispatch): 调度与冒险检测
  输入: (PC, 操作码, rs1, rs2, rd, 立即数)
  操作: 
    1) 从RegisterFile读操作数
    2) 检测RAW和WAW冒险
    3) 检测资源冒险（执行单元忙）
    4) 选择合适的执行单元并dispatch
  输出: (PC, 操作码, 操作数值, rd, 执行单元ID)
  延迟: 1周期
  
Stage 3 (Execute): 执行
  输入: (操作码, 操作数值)
  操作: 执行对应的操作（加法、乘法、访存地址计算等）
  输出: (结果值, rd)
  延迟: 1-4周期（取决于操作类型）
       - ALU: 1周期
       - MLU: 3-4周期
       - LSU: 1周期(L1 Hit), 10+周期(Miss)
  
Stage 4 (Writeback): 结果写回
  输入: (结果值, rd)
  操作: 将结果写入RegisterFile
  输出: 无
  延迟: 1周期
```

### Stage间的数据流动

```
时间线示例（理想无冒险情况）：

t=0: Instr0 处于 Fetch → 读取指令
t=1: Instr0 处于 Decode     Instr1 处于 Fetch
t=2: Instr0 处于 Dispatch   Instr1 处于 Decode     Instr2 处于 Fetch
t=3: Instr0 处于 Execute    Instr1 处于 Dispatch   Instr2 处于 Decode     Instr3 处于 Fetch
t=4: Instr0 处于 Writeback  Instr1 处于 Execute    Instr2 处于 Dispatch   Instr3 处于 Decode     Instr4 处于 Fetch
t=5: Instr1 完成             Instr2 处于 Execute    Instr3 处于 Dispatch   Instr4 处于 Decode     Instr5 处于 Fetch

吞吐量: 理想情况 = 1指令/周期
```

## 3.2.2 各阶段的详细实现

### Fetch阶段的实现

**核心职责**：
1. 根据PC从I-Cache读取指令
2. 更新PC
3. 处理分支预测与分支修正

**设计考量**：

I-Cache的建模通常采用简化模型。在架构级模拟中，可以假设：
- Hit延迟：1周期
- Miss延迟：10-20周期（取决于L2/内存的配置）
- 缓冲区大小：限制未完成的Fetch请求数

```
Fetch的主要工作：
while (can_fetch):
  address = current_pc
  instruction = fetch_from_icache(address)
  
  // 处理分支目标
  if is_branch(instruction):
    if branch_prediction(instruction):
      current_pc = predicted_target
    else:
      current_pc = next_pc + immediate
  else:
    current_pc = next_pc + 4
  
  output_instr = (current_pc, instruction)
```

**分支预测的影响**：
如果分支预测准确率为P，那么预测错误率为1-P。每次预测错误会导致流水线flush，损失约4周期的指令（流水线深度）。这对总体性能有显著影响。

### Decode阶段的实现

**核心职责**：
1. 指令格式识别（R-type, I-type, S-type等）
2. 字段提取（opcode, rs1, rs2, rd, immediate）
3. 指令类型确定（算术、逻辑、访存、分支等）

**RISC-V指令格式**：

```
R-type: [opcode(7)][rd(5)][funct3(3)][rs1(5)][rs2(5)][funct7(7)]
        用于: add, sub, mul, and, or等

I-type: [opcode(7)][rd(5)][funct3(3)][rs1(5)][imm(12)]
        用于: addi, lw, sw等

其他格式: U-type, S-type, B-type, J-type
```

**Decode的基本流程**：

```cpp
// 伪代码
uint32_t instr = fetch_packet.instruction;
uint32_t opcode = instr & 0x7f;

switch (opcode) {
  case 0x33: // R-type: ADD, SUB, MUL等
    rd = (instr >> 7) & 0x1f;
    rs1 = (instr >> 15) & 0x1f;
    rs2 = (instr >> 20) & 0x1f;
    funct7 = (instr >> 25) & 0x7f;
    funct3 = (instr >> 12) & 0x7;
    
    if (funct7 == 0x00 && funct3 == 0x0) op = ALU_ADD;
    else if (funct7 == 0x20 && funct3 == 0x0) op = ALU_SUB;
    else if (funct7 == 0x01 && funct3 == 0x0) op = ALU_MUL;
    ...
    break;
    
  case 0x13: // I-type: ADDI, ANDI等
    rd = (instr >> 7) & 0x1f;
    rs1 = (instr >> 15) & 0x1f;
    imm = sign_extend((instr >> 20) & 0xfff);
    ...
    break;
}
```

### Dispatch阶段的实现

**核心职责**：
1. 从RegisterFile读操作数
2. 冒险检测（RAW、WAW、结构冒险）
3. 选择执行单元
4. 发射到执行阶段

**Dispatch的冒险检测**：

```
RAW冒险检测（Read After Write）:
  当前指令读取 rs1 或 rs2
  前面的指令写入 rs1 或 rs2
  且前面的指令尚未完成
  → 停止当前指令的Dispatch

实现：使用Scoreboard记录每个寄存器的"忙"状态
```

**Scoreboard的数据结构**：

```
struct Scoreboard {
  bool busy[32];           // 每个寄存器是否忙
  int producer[32];        // 哪条指令在写这个寄存器
  int producer_stage[32];  // 那条指令在哪个阶段
};

当寄存器被写时，busy[rd] = true
当写入Writeback完成时，busy[rd] = false
```

**资源冒险检测**：

```
不同的执行单元有不同的延迟和吞吐量：
  ALU: 1周期延迟, 无延迟向下个指令
  MLU: 4周期延迟, 可接受下一个乘法（乱序执行）
  LSU: 可变延迟, 最多N个未完成的访存

检测资源冒险：
  if (op_type == MULTIPLY):
    if (mlu_pending_count >= mlu_max):
      stall = true
  if (op_type == LOAD || op_type == STORE):
    if (lsu_pending_count >= lsu_max):
      stall = true
```

### Execute阶段的实现

**执行单元的设计**：

Coral NPU包含多个专用执行单元：

```
1. ALU (Arithmetic Logic Unit)
   - 支持操作：ADD, SUB, AND, OR, XOR, SLL, SRL等
   - 延迟：1周期
   - 操作数：两个32-bit整数
   - 结果：32-bit整数

2. MLU (Multiply/Divide Unit)
   - 支持操作：MUL, MULH, DIV, REM等
   - 延迟：
     * MUL: 3-4周期
     * DIV: 32-40周期（迭代相除）
   - 操作数：两个32-bit整数
   - 结果：32-bit或64-bit（取决于操作）

3. LSU (Load/Store Unit)
   - 支持操作：LW, LB, LH, SW, SB, SH等
   - 延迟：
     * L1 Cache Hit: 3-4周期
     * L1 Cache Miss: 10+周期
   - 功能：地址计算、缓存访问、权限检查

4. BRU (Branch Unit, 可选)
   - 支持操作：JAL, JALR, BEQ等
   - 功能：分支地址计算、分支预测修正
```

**执行的流程**：

```
for each_cycle:
  for each_pending_instruction:
    if instruction.stage == EXECUTE:
      if instruction.execution_unit.is_ready():
        result = execute(instruction)
        instruction.result = result
        instruction.stage = WRITEBACK
```

### Writeback阶段的实现

**核心职责**：
1. 将执行结果写入RegisterFile
2. 更新Scoreboard（标记寄存器不再忙）
3. 可能唤醒等待该寄存器的指令

**Writeback的挑战**：

在多执行单元系统中，多条指令可能同时到达Writeback阶段，都需要写入RegisterFile。但RegisterFile的写端口是有限的（通常8个）。

**仲裁策略**：

```
当多个指令竞争写端口时，采用以下仲裁策略之一：

1. 优先级仲裁：
   - ALU指令优先级最高（频繁、延迟短）
   - LSU指令优先级次之
   - MLU指令优先级最低（已经等很久了）

2. 轮询仲裁：
   - 轮流选择不同执行单元的指令

3. 年龄优先：
   - 最早发射的指令优先写入
   - 这保证了FIFO语义
```

## 3.2.3 冒险处理与流水线停止

### 三类冒险的详细分析

**RAW冒险（数据依赖最常见的类型）**：

```
示例指令序列：
  I0: add x1, x2, x3
  I1: mul x4, x1, x5    <- I1依赖I0的x1

处理：
  I0 在Dispatch时发射到ALU（延迟1周期）
  I1 在Dispatch时，检查x1的Scoreboard
  → x1标记为忙（I0在Execute）
  → I1停止（Stall）
  
  I0 进入Execute，1周期后进入Writeback
  I0的Writeback完成，x1不再忙
  
  I1可以继续Dispatch
```

**WAW冒险（乱序执行系统中常见，但这里主要讨论）**：

```
在顺序流水线中，WAW冒险不会发生，因为指令按顺序到达Execute。
但如果MLU的延迟导致乱序完成，需要特殊处理。

示例：
  I0: add x1, x2, x3       (延迟1周期)
  I1: mul x1, x4, x5       (延迟4周期)
  
  I0和I1都会写x1，但I1的延迟更长，可能导致结果顺序颠倒。
  
解决方案：
  - 使用Reorder Buffer (ROB) 确保结果按程序顺序提交
  - 或者使用时间戳机制，最新的时间戳的值有效
```

**结构冒险（硬件资源竞争）**：

```
示例：两个乘法指令竞争MLU

  I0: mul x1, x2, x3
  I1: mul x4, x5, x6    <- 也需要MLU，但MLU正忙

处理：
  I0 dispatch时，mlu_busy = false, 发射到MLU
  I1 dispatch时，mlu_busy = true, I1停止
  I0在MLU中执行4周期
  I0 Writeback完成，mlu_busy = false
  I1可以dispatch
```

### 停止的性能影响

停止是流水线性能的主要杀手。停止的CPI（Cycles Per Instruction）影响：

```
总时间 = 指令数 × (基础CPI + 冒险引起的额外周期)

基础CPI（无冒险）≈ 1

额外周期来自于：
  - RAW冒险停止
  - Cache Miss（LSU等待）
  - 分支预测错误（Pipeline flush）
  - 资源冒险（竞争执行单元）

例如，如果停止率为20%，那么有效CPI = 1.25
这意味着每完成100条指令，需要125个周期
```

## 3.2.4 流水线的性能特征

### 吞吐量与延迟的特性

```
吞吐量 = min(每周期dispatch的指令数, 每周期完成的指令数)
      = min(1, 8/周期的寄存器写回) = 1指令/周期（理想情况）

延迟 = 从指令进入Fetch到Writeback完成的周期数
     = 5周期（无冒险、无等待）
     = 5 + 冒险等待周期（通常情况）
```

### 关键路径分析

流水线的关键路径由以下因素决定：

```
1. 指令依赖链的长度
   - 最长的指令依赖链决定了最小CPI
   - 示例：mul的结果被用于下一条add，需要等4+1=5周期

2. Cache Miss的频率与延迟
   - 如果30%的Load发生Miss，平均延迟30周期
   - 对总体性能有显著影响

3. 分支预测的准确率
   - 每次预测错误损失约4-5周期
   - 准确率95% → 平均每100指令损失5×5=25周期
```

## 小结

标量核心的5级流水线是Coral NPU的传统指令执行引擎。通过多个执行单元、冒险检测、和背压机制，流水线能够达到接近1指令/周期的吞吐量。然而，数据冒险、Cache延迟、和分支预测错误会显著降低实际吞吐量。理解这些性能因素对于优化处理器设计至关重要。

---

**下一节**: [3.3 功能单元的详细设计](./3.3-功能单元的详细设计.md)