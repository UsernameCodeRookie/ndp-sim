# 硬件-软件协同设计框架说明

## 重组背景

原来的论文结构是线性的：理论 → 框架 → 硬件案例 → 调度案例。这虽然逻辑清晰，但容易让读者以为这四个部分是独立的，只是按顺序展开。

新的结构强调了**硬件和调度之间的相互驱动关系**，体现了现代AI芯片系统设计的本质：
- 硬件特性约束调度算法的设计空间
- 调度需求驱动硬件优化方向
- 模拟器是连接两者的关键工具

## 新结构的核心思想

### 5部分递进式组织

```
Part 1: 基础理论 (事件驱动模拟)
    ↓
Part 2: 框架设计 (统一建模架构)
    ↓ 
Part 3: 应用案例
    ├─ 硬件案例：Coral NPU处理器
    └─ 调度案例：LLM推理系统
         (相互引用、体现约束关系)
    ↓
Part 4: 协同方法论 (设计闭环)
```

### 阅读路径的多维性

原来的路径是"线性的"：快速 → 标准 → 深入

现在的路径是"多维的"：
- **硬件优先**：关注处理器设计如何成为调度的约束
- **调度优先**：关注调度需求如何驱动硬件评估
- **协同视角**：在硬件和调度之间建立显式的反馈关系
- **快速参考**：针对具体问题快速定位相关内容

## 第三、四章的协同设计亮点

### 原来的安排
```
第三章：Coral NPU处理器
  - 5级流水线、向量执行引擎等硬件特性
  - 目的：展示框架在硬件建模中的应用

第四章：LLM推理调度  
  - 优先级队列、动态批处理等调度算法
  - 目的：展示框架在推理系统中的应用
  - (与第三章的关系不明确)
```

### 新安排的协同体现

#### 第三章：Coral NPU处理器的建模与硬件-调度协同分析
强调硬件特性与调度的关系：
- 3.1: 硬件架构 → 提供的执行能力
- 3.2: 流水线设计 → 调度需要理解的约束
- 3.3: 功能单元 → 调度的资源模型
- 3.4: 寄存器与冒险 → 调度的依赖追踪参考
- 3.5: 向量执行 → 调度对向量资源的理解
- 3.6: 微体系结构优化 → 硬件给予调度的选项
- 3.7: 硬件集成设计 → 调度优化的基础

**关键设计**：每一节都明确指出"这个硬件特性如何影响调度决策"

#### 第四章：LLM推理调度的设计与硬件-调度协同优化
体现调度与硬件的反馈关系：
- 4.1: 推理特性 vs 硬件特性（匹配分析）
- 4.2: 调度算法 vs 硬件约束（协同设计）
- 4.3: 缓存策略 vs 硬件缓存（协同优化）
- 4.4: 并发调度 vs 硬件资源竞争（权衡分析）
- 4.5: 性能模型 vs 硬件性能数据（验证与反馈）
- 4.6: 资源优化 vs 硬件能力（调度决策）
- 4.7: 实验评估 vs 协同优化（迭代反馈）

**关键设计**：每一节都问"调度如何在硬件约束下做出最优选择，同时硬件如何通过性能反馈来改进"

## 文件组织的演变

### 原来
```
papers/
├── chapter1
├── chapter2
├── chapter3
└── chapter4
```
**问题**：平铺式，看不出关系

### 现在
```
paper/
├── part1-foundations/
│   └── chapter1 (共同基础)
├── part2-framework/
│   └── chapter2 (共同工具)
├── part3-applications/
│   ├── chapter3-coral-npu/ (硬件案例)
│   └── chapter4-llm-inference-scheduling/ (调度案例，相互关联)
└── appendix/
    └── codesign-methodology.md (协同原理)
```

**优点**：
- 逻辑层级明确
- 强调各部分的关系
- 体现"基础 → 框架 → 应用"的递进
- 强调"硬件和调度是应用层并行的两个方向"

## 协同设计的核心循环

### 迭代循环 1：模拟器驱动硬件优化

```
调度分析 (第四章)
    ↓
"缓存miss是瓶颈" / "内存带宽不足"
    ↓
模拟器评估 (用第二章的框架)
    ↓
硬件设计调整 (改进第三章的设计)
    ↓
重新评估调度性能
    ↓ (反馈)
调度算法微调
```

### 迭代循环 2：调度需求指导硬件评估

```
硬件设计 (第三章)
    ↓
"向量执行宽度应该是多少？"
    ↓
调度模型 (第四章)
    ↓
"在调度约束下，8-lane vs 16-lane的性能/成本比"
    ↓
模拟器评估 (第二章的框架)
    ↓
硬件决策 (第三章定型)
```

## 关键改进点

1. **论文主题的演变**
   - 原：事件驱动的架构模拟框架
   - 新：事件驱动的架构模拟与推理调度的协同设计
   - **效果**：突出"协同"而不是"两个独立系统"

2. **阅读路径的灵活性**
   - 原：快速 → 标准 → 深入（顺序约束）
   - 新：硬件优先/调度优先/协同视角/快速参考（任选）
   - **效果**：满足不同背景的读者

3. **第三、四章的联系**
   - 原：分别介绍硬件和调度
   - 新：每章都明确指出另一方的约束/需求
   - **效果**：理解系统的整体性

4. **方法论的显式化**
   - 原：隐含在案例中
   - 新：明确的"协同设计方法论"补充
   - **效果**：读者可以复用这个方法到其他项目

## 对读者的帮助

### 硬件设计师
从新结构可以清楚看到：
- 自己设计的硬件如何被软件约束和利用
- 如何通过模拟器快速评估硬件改进
- 与软件工程师的协同设计流程

### 软件工程师
从新结构可以清楚看到：
- 硬件提供的资源和约束
- 如何在硬件约束下设计高效的调度
- 如何通过模拟器来验证设计

### 研究者
从新结构可以清楚看到：
- 事件驱动框架的通用性
- 硬件-软件协同设计的方法论
- 性能建模与优化的完整流程
- 可以复用到其他领域（GPU调度、内存系统等）

## 版本说明

**旧版本**：3章 + 1章 = 4个独立的话题
**新版本**：5部分 + 方法论 = 一个协同的系统

新版本保持内容不变，但通过组织结构的调整，使得协同设计的思想更加明显和易于理解。

## 下一步建议

1. **更新各章README**：在每个chapter的README中，明确指出它与其他章的关系
   
2. **交叉引用**：
   - 第三章硬件小节 → 引用第四章相关需求
   - 第四章调度小节 → 引用第三章相关约束
   
3. **补充协同方法论**：创建 appendix/codesign-methodology.md
   - 硬件性能数据 → 调度约束的映射方法
   - 调度优化 → 硬件反馈的收集方法
   - 快速迭代的设计流程

4. **可视化协同循环**：
   - 在各章README中加入协同循环图
   - 示例：硬件瓶颈如何反映在调度性能上
